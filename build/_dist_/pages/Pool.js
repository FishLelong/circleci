/* src/pages/Pool.svelte generated by Svelte v3.29.0 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import AllocationBreakdown from "../components/AllocationBreakdown.js";
import Balance from "../components/Balance.js";
import Etherscan from "../components/Etherscan.js";
import Farming from "../components/Farming.js";
import Info from "../components/Info.js";
import Liquidity from "../components/Liquidity.js";
import Quantstamp from "../components/Quantstamp.js";
import images from "../config/images.json.proxy.js";
import { currentRoute } from "../stores/routes.js";

function create_fragment(ctx) {
	let div9;
	let div8;
	let div6;
	let div5;
	let div0;
	let balance;
	let t0;
	let div1;
	let farming;
	let t1;
	let div2;
	let allocationbreakdown;
	let t2;
	let div3;
	let etherscan;
	let t3;
	let div4;
	let quantstamp;
	let t4;
	let div7;
	let liquidity;
	let current;

	balance = new Balance({
			props: {
				token: /*$currentRoute*/ ctx[0].params.address
			}
		});

	farming = new Farming({
			props: {
				token: /*$currentRoute*/ ctx[0].params.address
			}
		});

	allocationbreakdown = new AllocationBreakdown({
			props: {
				token: /*$currentRoute*/ ctx[0].params.address
			}
		});

	etherscan = new Etherscan({
			props: {
				token: /*$currentRoute*/ ctx[0].params.address
			}
		});

	quantstamp = new Quantstamp({
			props: {
				class: "my-2",
				token: /*$currentRoute*/ ctx[0].params.address
			}
		});

	liquidity = new Liquidity({
			props: {
				token: /*$currentRoute*/ ctx[0].params.address,
				method: /*$currentRoute*/ ctx[0].params.method,
				poolAction: /*$currentRoute*/ ctx[0].params.poolAction
			}
		});

	return {
		c() {
			div9 = element("div");
			div8 = element("div");
			div6 = element("div");
			div5 = element("div");
			div0 = element("div");
			create_component(balance.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(farming.$$.fragment);
			t1 = space();
			div2 = element("div");
			create_component(allocationbreakdown.$$.fragment);
			t2 = space();
			div3 = element("div");
			create_component(etherscan.$$.fragment);
			t3 = space();
			div4 = element("div");
			create_component(quantstamp.$$.fragment);
			t4 = space();
			div7 = element("div");
			create_component(liquidity.$$.fragment);
			attr(div0, "class", "left flex-1 mr-4");
			attr(div1, "class", "left flex-1 mt-4 mr-4");
			attr(div2, "class", "hidden md:block");
			attr(div3, "class", "left flex-1 mt-4 mr-4");
			attr(div4, "class", "right flex-1 mt-4 mr-4");
			attr(div5, "class", "flex hidden md:block");
			attr(div6, "class", "left flex-1");
			attr(div7, "class", "right w-full md:w-2/4 flex md:flex-1 md:ml-2");
			attr(div8, "class", "flex flex-col w-full flex-row-reverse md:flex-row");
			attr(div9, "class", "content flex flex-col");
		},
		m(target, anchor) {
			insert(target, div9, anchor);
			append(div9, div8);
			append(div8, div6);
			append(div6, div5);
			append(div5, div0);
			mount_component(balance, div0, null);
			append(div5, t0);
			append(div5, div1);
			mount_component(farming, div1, null);
			append(div5, t1);
			append(div5, div2);
			mount_component(allocationbreakdown, div2, null);
			append(div5, t2);
			append(div5, div3);
			mount_component(etherscan, div3, null);
			append(div5, t3);
			append(div5, div4);
			mount_component(quantstamp, div4, null);
			append(div8, t4);
			append(div8, div7);
			mount_component(liquidity, div7, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const balance_changes = {};
			if (dirty & /*$currentRoute*/ 1) balance_changes.token = /*$currentRoute*/ ctx[0].params.address;
			balance.$set(balance_changes);
			const farming_changes = {};
			if (dirty & /*$currentRoute*/ 1) farming_changes.token = /*$currentRoute*/ ctx[0].params.address;
			farming.$set(farming_changes);
			const allocationbreakdown_changes = {};
			if (dirty & /*$currentRoute*/ 1) allocationbreakdown_changes.token = /*$currentRoute*/ ctx[0].params.address;
			allocationbreakdown.$set(allocationbreakdown_changes);
			const etherscan_changes = {};
			if (dirty & /*$currentRoute*/ 1) etherscan_changes.token = /*$currentRoute*/ ctx[0].params.address;
			etherscan.$set(etherscan_changes);
			const quantstamp_changes = {};
			if (dirty & /*$currentRoute*/ 1) quantstamp_changes.token = /*$currentRoute*/ ctx[0].params.address;
			quantstamp.$set(quantstamp_changes);
			const liquidity_changes = {};
			if (dirty & /*$currentRoute*/ 1) liquidity_changes.token = /*$currentRoute*/ ctx[0].params.address;
			if (dirty & /*$currentRoute*/ 1) liquidity_changes.method = /*$currentRoute*/ ctx[0].params.method;
			if (dirty & /*$currentRoute*/ 1) liquidity_changes.poolAction = /*$currentRoute*/ ctx[0].params.poolAction;
			liquidity.$set(liquidity_changes);
		},
		i(local) {
			if (current) return;
			transition_in(balance.$$.fragment, local);
			transition_in(farming.$$.fragment, local);
			transition_in(allocationbreakdown.$$.fragment, local);
			transition_in(etherscan.$$.fragment, local);
			transition_in(quantstamp.$$.fragment, local);
			transition_in(liquidity.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(balance.$$.fragment, local);
			transition_out(farming.$$.fragment, local);
			transition_out(allocationbreakdown.$$.fragment, local);
			transition_out(etherscan.$$.fragment, local);
			transition_out(quantstamp.$$.fragment, local);
			transition_out(liquidity.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div9);
			destroy_component(balance);
			destroy_component(farming);
			destroy_component(allocationbreakdown);
			destroy_component(etherscan);
			destroy_component(quantstamp);
			destroy_component(liquidity);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $currentRoute;
	component_subscribe($$self, currentRoute, $$value => $$invalidate(0, $currentRoute = $$value));
	return [$currentRoute];
}

class Pool extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Pool;