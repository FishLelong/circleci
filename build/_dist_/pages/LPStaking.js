/* src/pages/LPStaking.svelte generated by Svelte v3.29.0 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	set_style,
	space,
	text
} from "../../web_modules/svelte/internal.js";

import { ethers } from "../../web_modules/ethers.js";
import { onMount } from "../../web_modules/svelte.js";
import BigNumber from "../../web_modules/bignumberjs.js";
import { validateIsAddress } from "../../web_modules/@pie-dao/utils.js";
import { _ } from "../../web_modules/svelte-i18n.js";
import images from "../config/images.json.proxy.js";
import { currentRoute } from "../stores/routes.js";
import filter from "../../web_modules/lodash/filter.js";
import isNaN from "../../web_modules/lodash/isNaN.js";
import recipeUnipool from "../config/unipoolABI.json.proxy.js";
import BALANCER_POOL_ABI from "../config/balancerPoolABI.json.proxy.js";
import geyserABI from "../config/geyser.json.proxy.js";
import { get } from "../../web_modules/svelte/store.js";
import displayNotification from "../notifications.js";
import { piesMarketDataStore } from "../stores/coingecko.js";
import { farming } from "../stores/eth/writables.js";

import {
	amountFormatter,
	fetchPieTokens,
	fetchPooledTokens,
	maxAmount,
	getTokenImage,
	fetchEthBalance,
	fetchCalcToPie,
	toFixed,
	calculateAPRBalancer,
	calculateAPRUniswap,
	formatFiat,
	subscribeToBalance,
	subscribeToAllowance,
	subscribeToStaking,
	subscribeToStakingEarnings,
	subscribeToStakingEarningsGeyser
} from "../components/helpers.js";

import {
	allowances,
	functionKey,
	approveMax,
	balanceKey,
	balances,
	connectWeb3,
	contract,
	eth,
	pools,
	bumpLifecycle,
	subject
} from "../stores/eth.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[39] = list[i];
	return child_ctx;
}

// (697:8) {:else}
function create_else_block_6(ctx) {
	let div0;
	let button0;
	let t0_value = /*$_*/ ctx[9]("general.back") + "";
	let t0;
	let t1;
	let t2;
	let div21;
	let div10;
	let img0;
	let img0_src_value;
	let t3;
	let div1;
	let t4;
	let t5;
	let div2;

	let t6_value = (/*pool*/ ctx[3].KeyAddressTokenToStake
	? amountFormatter({
			amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance],
			displayDecimals: 4
		})
	: 0) + "";

	let t6;
	let t7;
	let t8_value = /*pool*/ ctx[3].toStakeSymbol + "";
	let t8;
	let t9;
	let div3;
	let t11;
	let div4;
	let t12_value = /*pool*/ ctx[3].toStakeDesc + "";
	let t12;
	let t13;
	let div9;
	let div6;
	let t15;
	let div8;
	let input0;
	let t16;
	let div7;
	let button1;
	let t18;
	let t19;
	let div20;
	let img1;
	let img1_src_value;
	let t20;
	let div11;
	let t22;
	let div12;

	let t23_value = (/*pool*/ ctx[3].KeyAddressTokenToStake
	? amountFormatter({
			amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyAddressTokenToStake],
			displayDecimals: 4
		})
	: 0) + "";

	let t23;
	let t24;
	let t25_value = /*pool*/ ctx[3].toStakeSymbol + "";
	let t25;
	let t26;
	let div13;
	let t28;
	let div14;
	let t29_value = /*pool*/ ctx[3].toStakeDesc + "";
	let t29;
	let t30;
	let div19;
	let div16;
	let t32;
	let div18;
	let input1;
	let t33;
	let div17;
	let button2;
	let t35;
	let t36;
	let t37;
	let t38;
	let div22;
	let t39;
	let t40;
	let br0;
	let br1;
	let t41;
	let p0;
	let t42_value = /*$_*/ ctx[9]("stake.add.liquidity") + "";
	let t42;
	let t43;
	let t44_value = /*pool*/ ctx[3].platform + "";
	let t44;
	let t45;
	let t46_value = /*$_*/ ctx[9]("general.pool") + "";
	let t46;
	let t47;
	let t48_value = /*$_*/ ctx[9]("stake.to.get") + "";
	let t48;
	let t49;
	let t50_value = /*pool*/ ctx[3].toStakeSymbol + "";
	let t50;
	let t51;
	let t52_value = /*$_*/ ctx[9]("stake.tokens") + "";
	let t52;
	let t53;
	let a0;
	let t54_value = /*$_*/ ctx[9]("stake.here") + "";
	let t54;
	let a0_href_value;
	let t55;
	let p1;
	let t56_value = /*$_*/ ctx[9]("stake.weekly.rewards") + "";
	let t56;
	let t57;
	let strong;
	let t58_value = /*pool*/ ctx[3].weeklyRewards + "";
	let t58;
	let t59;
	let t60_value = /*pool*/ ctx[3].rewards_token + "";
	let t60;
	let t61;
	let p2;
	let t62_value = /*$_*/ ctx[9]("general.buy") + "";
	let t62;
	let t63;
	let t64_value = /*pool*/ ctx[3].containing[0].symbol + "";
	let t64;
	let t65;
	let t66_value = /*$_*/ ctx[9]("general.on") + "";
	let t66;
	let t67;
	let a1;
	let t68;
	let a1_href_value;
	let t69;
	let t70_value = /*$_*/ ctx[9]("general.or") + "";
	let t70;
	let t71;
	let a2;
	let t72;
	let a2_href_value;
	let t73;
	let p3;
	let t74_value = /*$_*/ ctx[9]("general.buy") + "";
	let t74;
	let t75;
	let t76_value = /*$_*/ ctx[9]("general.on") + "";
	let t76;
	let t77;
	let a3;
	let mounted;
	let dispose;
	let if_block0 = /*pool*/ ctx[3].KeyAddressTokenToStake && /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] > 0 && /*pool*/ ctx[3].contractType !== "Geyser" && create_if_block_19(ctx);
	let if_block1 = /*pool*/ ctx[3].contractType === "Geyser" && create_if_block_18(ctx);

	function select_block_type_7(ctx, dirty) {
		if (/*amountToUnstake*/ ctx[1] === 0) return create_if_block_17;
		return create_else_block_8;
	}

	let current_block_type = select_block_type_7(ctx, [-1]);
	let if_block2 = current_block_type(ctx);

	function select_block_type_8(ctx, dirty) {
		if (/*needAllowance*/ ctx[5]) return create_if_block_15;
		if (/*amountToStake*/ ctx[0] === 0) return create_if_block_16;
		return create_else_block_7;
	}

	let current_block_type_1 = select_block_type_8(ctx, [-1]);
	let if_block3 = current_block_type_1(ctx);
	let if_block4 = /*pool*/ ctx[3].contractType === "UniPool" && create_if_block_14(ctx);
	let if_block5 = /*pool*/ ctx[3].contractType === "Geyser" && create_if_block_13(ctx);
	let if_block6 = /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll] !== undefined && create_if_block_11(ctx);
	let if_block7 = /*pool*/ ctx[3].contractType === "Geyser" && create_if_block_10(ctx);

	return {
		c() {
			div0 = element("div");
			button0 = element("button");
			t0 = text(t0_value);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			div21 = element("div");
			div10 = element("div");
			img0 = element("img");
			t3 = space();
			div1 = element("div");
			t4 = text("UNSTAKE ");
			if (if_block1) if_block1.c();
			t5 = space();
			div2 = element("div");
			t6 = text(t6_value);
			t7 = space();
			t8 = text(t8_value);
			t9 = space();
			div3 = element("div");
			div3.textContent = "STAKED BALANCE";
			t11 = space();
			div4 = element("div");
			t12 = text(t12_value);
			t13 = space();
			div9 = element("div");
			div6 = element("div");
			div6.innerHTML = `<div class="left float-left">Amount to unstake</div>`;
			t15 = space();
			div8 = element("div");
			input0 = element("input");
			t16 = space();
			div7 = element("div");
			button1 = element("button");
			button1.textContent = "MAX";
			t18 = space();
			if_block2.c();
			t19 = space();
			div20 = element("div");
			img1 = element("img");
			t20 = space();
			div11 = element("div");
			div11.textContent = "STAKE";
			t22 = space();
			div12 = element("div");
			t23 = text(t23_value);
			t24 = space();
			t25 = text(t25_value);
			t26 = space();
			div13 = element("div");
			div13.textContent = "BALANCE";
			t28 = space();
			div14 = element("div");
			t29 = text(t29_value);
			t30 = space();
			div19 = element("div");
			div16 = element("div");
			div16.innerHTML = `<div class="text-black left black float-left">Amount to stake</div>`;
			t32 = space();
			div18 = element("div");
			input1 = element("input");
			t33 = space();
			div17 = element("div");
			button2 = element("button");
			button2.textContent = "MAX";
			t35 = space();
			if_block3.c();
			t36 = space();
			if (if_block4) if_block4.c();
			t37 = space();
			if (if_block5) if_block5.c();
			t38 = space();
			div22 = element("div");
			if (if_block6) if_block6.c();
			t39 = space();
			if (if_block7) if_block7.c();
			t40 = space();
			br0 = element("br");
			br1 = element("br");
			t41 = space();
			p0 = element("p");
			t42 = text(t42_value);
			t43 = space();
			t44 = text(t44_value);
			t45 = space();
			t46 = text(t46_value);
			t47 = space();
			t48 = text(t48_value);
			t49 = space();
			t50 = text(t50_value);
			t51 = space();
			t52 = text(t52_value);
			t53 = space();
			a0 = element("a");
			t54 = text(t54_value);
			t55 = space();
			p1 = element("p");
			t56 = text(t56_value);
			t57 = space();
			strong = element("strong");
			t58 = text(t58_value);
			t59 = space();
			t60 = text(t60_value);
			t61 = space();
			p2 = element("p");
			t62 = text(t62_value);
			t63 = space();
			t64 = text(t64_value);
			t65 = space();
			t66 = text(t66_value);
			t67 = space();
			a1 = element("a");
			t68 = text("Balancer");
			t69 = space();
			t70 = text(t70_value);
			t71 = space();
			a2 = element("a");
			t72 = text("mint now!");
			t73 = space();
			p3 = element("p");
			t74 = text(t74_value);
			t75 = text(" CEPToken ");
			t76 = text(t76_value);
			t77 = space();
			a3 = element("a");
			a3.textContent = "Balancer";
			attr(button0, "class", "md:w-1 float-left btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
			attr(img0, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img0.src !== (img0_src_value = images.withdraw)) attr(img0, "src", img0_src_value);
			attr(img0, "alt", "PieDAO logo");
			attr(div1, "class", "title text-lg");
			attr(div2, "class", "apy");
			attr(div3, "class", "subtitle font-thin");
			attr(div4, "class", "apy text-sm");
			attr(div6, "class", "top h-24px text-sm font-thin px-4 py-4 md:py-2");
			attr(input0, "type", "text");
			attr(input0, "class", "text-black font-thin text-base w-60pc md:w-75pc md:text-lg");
			attr(button1, "class", "text-black py-2px px-4px");
			attr(div7, "class", "text-black asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex align-middle justify-center items-center pointer mt-0");
			attr(div8, "class", "bottom px-4 py-4 md:py-2");
			attr(div9, "class", "w-80 input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(div10, "class", "farming-card flex flex-col justify-center align-center items-center mx-1 my-4  border border-gray border-opacity-50 border-solid rounded-sm py-2");
			attr(img1, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img1.src !== (img1_src_value = images.stake)) attr(img1, "src", img1_src_value);
			attr(img1, "alt", "PieDAO logo");
			attr(div11, "class", "title text-lg");
			attr(div12, "class", "apy");
			attr(div13, "class", "subtitle font-thin");
			attr(div14, "class", "apy text-sm");
			attr(div16, "class", "top h-24px text-sm font-thin px-4 py-4 md:py-2");
			attr(input1, "type", "text");
			attr(input1, "class", "text-black font-thin text-base w-60pc md:w-75pc md:text-lg");
			attr(button2, "class", "text-black py-2px px-4px");
			attr(div17, "class", "text-black asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex align-middle justify-center items-center pointer mt-0");
			attr(div18, "class", "bottom px-4 py-4 md:py-2");
			attr(div19, "class", "w-80 input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(div20, "class", "farming-card highlight-box flex flex-col justify-center align-center items-center mx-1 my-4  border border-grey border-opacity-50 border-solid rounded-sm py-2");
			attr(div21, "class", "flex flex-col w-full justify-around md:flex-row");
			attr(a0, "href", a0_href_value = /*pool*/ ctx[3].poolLink);
			attr(a1, "target", "_blank");
			attr(a1, "href", a1_href_value = "https://balancer.exchange/#/swap/ether/" + /*pool*/ ctx[3].containing[0].address);
			attr(a2, "href", a2_href_value = "#/pools/" + /*pool*/ ctx[3].containing[0].address);
			attr(a3, "target", "_blank");
			attr(a3, "href", "https://balancer.exchange/#/swap/ether/0xad32A8e6220741182940c5aBF610bDE99E737b2D");
			attr(div22, "class", "info-box");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, button0);
			append(button0, t0);
			append(div0, t1);
			if (if_block0) if_block0.m(div0, null);
			insert(target, t2, anchor);
			insert(target, div21, anchor);
			append(div21, div10);
			append(div10, img0);
			append(div10, t3);
			append(div10, div1);
			append(div1, t4);
			if (if_block1) if_block1.m(div1, null);
			append(div10, t5);
			append(div10, div2);
			append(div2, t6);
			append(div2, t7);
			append(div2, t8);
			append(div10, t9);
			append(div10, div3);
			append(div10, t11);
			append(div10, div4);
			append(div4, t12);
			append(div10, t13);
			append(div10, div9);
			append(div9, div6);
			append(div9, t15);
			append(div9, div8);
			append(div8, input0);
			set_input_value(input0, /*amountToUnstake*/ ctx[1]);
			append(div8, t16);
			append(div8, div7);
			append(div7, button1);
			append(div10, t18);
			if_block2.m(div10, null);
			append(div21, t19);
			append(div21, div20);
			append(div20, img1);
			append(div20, t20);
			append(div20, div11);
			append(div20, t22);
			append(div20, div12);
			append(div12, t23);
			append(div12, t24);
			append(div12, t25);
			append(div20, t26);
			append(div20, div13);
			append(div20, t28);
			append(div20, div14);
			append(div14, t29);
			append(div20, t30);
			append(div20, div19);
			append(div19, div16);
			append(div19, t32);
			append(div19, div18);
			append(div18, input1);
			set_input_value(input1, /*amountToStake*/ ctx[0]);
			append(div18, t33);
			append(div18, div17);
			append(div17, button2);
			append(div20, t35);
			if_block3.m(div20, null);
			append(div21, t36);
			if (if_block4) if_block4.m(div21, null);
			append(div21, t37);
			if (if_block5) if_block5.m(div21, null);
			insert(target, t38, anchor);
			insert(target, div22, anchor);
			if (if_block6) if_block6.m(div22, null);
			append(div22, t39);
			if (if_block7) if_block7.m(div22, null);
			append(div22, t40);
			append(div22, br0);
			append(div22, br1);
			append(div22, t41);
			append(div22, p0);
			append(p0, t42);
			append(p0, t43);
			append(p0, t44);
			append(p0, t45);
			append(p0, t46);
			append(p0, t47);
			append(p0, t48);
			append(p0, t49);
			append(p0, t50);
			append(p0, t51);
			append(p0, t52);
			append(p0, t53);
			append(p0, a0);
			append(a0, t54);
			append(div22, t55);
			append(div22, p1);
			append(p1, t56);
			append(p1, t57);
			append(p1, strong);
			append(strong, t58);
			append(strong, t59);
			append(strong, t60);
			append(div22, t61);
			append(div22, p2);
			append(p2, t62);
			append(p2, t63);
			append(p2, t64);
			append(p2, t65);
			append(p2, t66);
			append(p2, t67);
			append(p2, a1);
			append(a1, t68);
			append(p2, t69);
			append(p2, t70);
			append(p2, t71);
			append(p2, a2);
			append(a2, t72);
			append(div22, t73);
			append(div22, p3);
			append(p3, t74);
			append(p3, t75);
			append(p3, t76);
			append(p3, t77);
			append(p3, a3);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler_2*/ ctx[17]),
					listen(input0, "input", /*input0_input_handler*/ ctx[19]),
					listen(button1, "click", /*click_handler_4*/ ctx[20]),
					listen(input1, "input", /*input1_input_handler*/ ctx[22]),
					listen(button2, "click", /*click_handler_6*/ ctx[23])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 512 && t0_value !== (t0_value = /*$_*/ ctx[9]("general.back") + "")) set_data(t0, t0_value);

			if (/*pool*/ ctx[3].KeyAddressTokenToStake && /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] > 0 && /*pool*/ ctx[3].contractType !== "Geyser") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_19(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*pool*/ ctx[3].contractType === "Geyser") {
				if (if_block1) {
					
				} else {
					if_block1 = create_if_block_18(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*pool, $balances*/ 24 && t6_value !== (t6_value = (/*pool*/ ctx[3].KeyAddressTokenToStake
			? amountFormatter({
					amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance],
					displayDecimals: 4
				})
			: 0) + "")) set_data(t6, t6_value);

			if (dirty[0] & /*pool*/ 8 && t8_value !== (t8_value = /*pool*/ ctx[3].toStakeSymbol + "")) set_data(t8, t8_value);
			if (dirty[0] & /*pool*/ 8 && t12_value !== (t12_value = /*pool*/ ctx[3].toStakeDesc + "")) set_data(t12, t12_value);

			if (dirty[0] & /*amountToUnstake*/ 2 && input0.value !== /*amountToUnstake*/ ctx[1]) {
				set_input_value(input0, /*amountToUnstake*/ ctx[1]);
			}

			if (current_block_type === (current_block_type = select_block_type_7(ctx, dirty)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(div10, null);
				}
			}

			if (dirty[0] & /*pool, $balances*/ 24 && t23_value !== (t23_value = (/*pool*/ ctx[3].KeyAddressTokenToStake
			? amountFormatter({
					amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyAddressTokenToStake],
					displayDecimals: 4
				})
			: 0) + "")) set_data(t23, t23_value);

			if (dirty[0] & /*pool*/ 8 && t25_value !== (t25_value = /*pool*/ ctx[3].toStakeSymbol + "")) set_data(t25, t25_value);
			if (dirty[0] & /*pool*/ 8 && t29_value !== (t29_value = /*pool*/ ctx[3].toStakeDesc + "")) set_data(t29, t29_value);

			if (dirty[0] & /*amountToStake*/ 1 && input1.value !== /*amountToStake*/ ctx[0]) {
				set_input_value(input1, /*amountToStake*/ ctx[0]);
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_8(ctx, dirty)) && if_block3) {
				if_block3.p(ctx, dirty);
			} else {
				if_block3.d(1);
				if_block3 = current_block_type_1(ctx);

				if (if_block3) {
					if_block3.c();
					if_block3.m(div20, null);
				}
			}

			if (/*pool*/ ctx[3].contractType === "UniPool") {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_14(ctx);
					if_block4.c();
					if_block4.m(div21, t37);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*pool*/ ctx[3].contractType === "Geyser") {
				if (if_block5) {
					if_block5.p(ctx, dirty);
				} else {
					if_block5 = create_if_block_13(ctx);
					if_block5.c();
					if_block5.m(div21, null);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll] !== undefined) {
				if (if_block6) {
					if_block6.p(ctx, dirty);
				} else {
					if_block6 = create_if_block_11(ctx);
					if_block6.c();
					if_block6.m(div22, t39);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*pool*/ ctx[3].contractType === "Geyser") {
				if (if_block7) {
					if_block7.p(ctx, dirty);
				} else {
					if_block7 = create_if_block_10(ctx);
					if_block7.c();
					if_block7.m(div22, t40);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (dirty[0] & /*$_*/ 512 && t42_value !== (t42_value = /*$_*/ ctx[9]("stake.add.liquidity") + "")) set_data(t42, t42_value);
			if (dirty[0] & /*pool*/ 8 && t44_value !== (t44_value = /*pool*/ ctx[3].platform + "")) set_data(t44, t44_value);
			if (dirty[0] & /*$_*/ 512 && t46_value !== (t46_value = /*$_*/ ctx[9]("general.pool") + "")) set_data(t46, t46_value);
			if (dirty[0] & /*$_*/ 512 && t48_value !== (t48_value = /*$_*/ ctx[9]("stake.to.get") + "")) set_data(t48, t48_value);
			if (dirty[0] & /*pool*/ 8 && t50_value !== (t50_value = /*pool*/ ctx[3].toStakeSymbol + "")) set_data(t50, t50_value);
			if (dirty[0] & /*$_*/ 512 && t52_value !== (t52_value = /*$_*/ ctx[9]("stake.tokens") + "")) set_data(t52, t52_value);
			if (dirty[0] & /*$_*/ 512 && t54_value !== (t54_value = /*$_*/ ctx[9]("stake.here") + "")) set_data(t54, t54_value);

			if (dirty[0] & /*pool*/ 8 && a0_href_value !== (a0_href_value = /*pool*/ ctx[3].poolLink)) {
				attr(a0, "href", a0_href_value);
			}

			if (dirty[0] & /*$_*/ 512 && t56_value !== (t56_value = /*$_*/ ctx[9]("stake.weekly.rewards") + "")) set_data(t56, t56_value);
			if (dirty[0] & /*pool*/ 8 && t58_value !== (t58_value = /*pool*/ ctx[3].weeklyRewards + "")) set_data(t58, t58_value);
			if (dirty[0] & /*pool*/ 8 && t60_value !== (t60_value = /*pool*/ ctx[3].rewards_token + "")) set_data(t60, t60_value);
			if (dirty[0] & /*$_*/ 512 && t62_value !== (t62_value = /*$_*/ ctx[9]("general.buy") + "")) set_data(t62, t62_value);
			if (dirty[0] & /*pool*/ 8 && t64_value !== (t64_value = /*pool*/ ctx[3].containing[0].symbol + "")) set_data(t64, t64_value);
			if (dirty[0] & /*$_*/ 512 && t66_value !== (t66_value = /*$_*/ ctx[9]("general.on") + "")) set_data(t66, t66_value);

			if (dirty[0] & /*pool*/ 8 && a1_href_value !== (a1_href_value = "https://balancer.exchange/#/swap/ether/" + /*pool*/ ctx[3].containing[0].address)) {
				attr(a1, "href", a1_href_value);
			}

			if (dirty[0] & /*$_*/ 512 && t70_value !== (t70_value = /*$_*/ ctx[9]("general.or") + "")) set_data(t70, t70_value);

			if (dirty[0] & /*pool*/ 8 && a2_href_value !== (a2_href_value = "#/pools/" + /*pool*/ ctx[3].containing[0].address)) {
				attr(a2, "href", a2_href_value);
			}

			if (dirty[0] & /*$_*/ 512 && t74_value !== (t74_value = /*$_*/ ctx[9]("general.buy") + "")) set_data(t74, t74_value);
			if (dirty[0] & /*$_*/ 512 && t76_value !== (t76_value = /*$_*/ ctx[9]("general.on") + "")) set_data(t76, t76_value);
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (if_block0) if_block0.d();
			if (detaching) detach(t2);
			if (detaching) detach(div21);
			if (if_block1) if_block1.d();
			if_block2.d();
			if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (detaching) detach(t38);
			if (detaching) detach(div22);
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (610:8) {#if !pool}
function create_if_block(ctx) {
	let h1;
	let t0_value = /*$_*/ ctx[9]("stake.select.a.pool") + "";
	let t0;
	let t1;
	let div;
	let each_value = filter(/*incentivizedPools*/ ctx[6], { deprecated: false });
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			h1 = element("h1");
			t0 = text(t0_value);
			t1 = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h1, "class", "text-center text-base sm:text-lg md:text-xl lg:text-2xl xl:text-3xl ");
			attr(div, "class", "flex flex-col w-full justify-center md:flex-row");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			append(h1, t0);
			insert(target, t1, anchor);
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 512 && t0_value !== (t0_value = /*$_*/ ctx[9]("stake.select.a.pool") + "")) set_data(t0, t0_value);

			if (dirty[0] & /*pool, incentivizedPools, $_, $farming, geyserApy*/ 968) {
				each_value = filter(/*incentivizedPools*/ ctx[6], { deprecated: false });
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (detaching) detach(t1);
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (700:14) {#if pool.KeyAddressTokenToStake && $balances[pool.KeyUnipoolBalance] > 0 && pool.contractType !== 'Geyser' }
function create_if_block_19(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Claim and Unstake";
			attr(button, "class", "float-right btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_3*/ ctx[18]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (709:55) {#if pool.contractType === "Geyser"}
function create_if_block_18(ctx) {
	let t;

	return {
		c() {
			t = text("and CLAIM");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (734:20) {:else}
function create_else_block_8(ctx) {
	let button;
	let t_value = /*$_*/ ctx[9]("general.unstake") + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_5*/ ctx[21]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 512 && t_value !== (t_value = /*$_*/ ctx[9]("general.unstake") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (732:20) {#if amountToUnstake === 0 }
function create_if_block_17(ctx) {
	let button;
	let t_value = /*$_*/ ctx[9]("stake.enter.amount") + "";
	let t;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			button.disabled = true;
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4 border-white");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 512 && t_value !== (t_value = /*$_*/ ctx[9]("stake.enter.amount") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (770:22) {:else}
function create_else_block_7(ctx) {
	let button;
	let t_value = /*$_*/ ctx[9]("general.stake") + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4 border-white");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_8*/ ctx[25]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 512 && t_value !== (t_value = /*$_*/ ctx[9]("general.stake") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (768:22) {#if amountToStake === 0 }
function create_if_block_16(ctx) {
	let button;
	let t_value = /*$_*/ ctx[9]("stake.enter.amount") + "";
	let t;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			button.disabled = true;
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4 border-white");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 512 && t_value !== (t_value = /*$_*/ ctx[9]("stake.enter.amount") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (765:20) {#if needAllowance }
function create_if_block_15(ctx) {
	let button;
	let t_value = /*$_*/ ctx[9]("stake.approve") + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4 border-white");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler_7*/ ctx[24]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 512 && t_value !== (t_value = /*$_*/ ctx[9]("stake.approve") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (777:14) {#if pool.contractType === "UniPool"}
function create_if_block_14(ctx) {
	let div8;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let t2;
	let div1;
	let t3_value = /*pool*/ ctx[3].rewards_token + "";
	let t3;
	let t4;
	let t5;
	let div2;

	let t6_value = (/*pool*/ ctx[3].KeyUnipoolEarnedBalance
	? amountFormatter({
			amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolEarnedBalance],
			displayDecimals: 16
		})
	: 0) + "";

	let t6;
	let t7;
	let t8_value = /*pool*/ ctx[3].rewards_token + "";
	let t8;
	let t9;
	let div7;
	let div4;
	let t11;
	let div6;
	let input;
	let t12;
	let div5;
	let button0;
	let t14;
	let button1;
	let t15_value = /*$_*/ ctx[9]("stake.claim") + "";
	let t15;
	let mounted;
	let dispose;

	return {
		c() {
			div8 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			div0.textContent = "REWARDS AVAILABLE";
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = text(" TO CLAIM");
			t5 = space();
			div2 = element("div");
			t6 = text(t6_value);
			t7 = space();
			t8 = text(t8_value);
			t9 = space();
			div7 = element("div");
			div4 = element("div");
			div4.innerHTML = `<div class="left float-left">Amount to claim</div>`;
			t11 = space();
			div6 = element("div");
			input = element("input");
			t12 = space();
			div5 = element("div");
			button0 = element("button");
			button0.textContent = "MAX";
			t14 = space();
			button1 = element("button");
			t15 = text(t15_value);
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.claim)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(div4, "class", "top h-24px text-sm font-thin px-4 py-4 md:py-2");
			input.disabled = true;
			attr(input, "type", "text");
			attr(input, "class", "text-black font-thin text-base w-60pc md:w-75pc md:text-lg");
			attr(button0, "class", "text-black py-2px px-4px");
			attr(div5, "class", "text-black asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex align-middle justify-center items-center pointer mt-0");
			attr(div6, "class", "bottom px-4 py-4 md:py-2");
			attr(div7, "class", "w-80 input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(button1, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
			attr(div8, "class", "farming-card flex flex-col justify-center align-center items-center mx-1 my-4  border border-gray border-opacity-50 border-solid rounded-sm py-2");
		},
		m(target, anchor) {
			insert(target, div8, anchor);
			append(div8, img);
			append(div8, t0);
			append(div8, div0);
			append(div8, t2);
			append(div8, div1);
			append(div1, t3);
			append(div1, t4);
			append(div8, t5);
			append(div8, div2);
			append(div2, t6);
			append(div2, t7);
			append(div2, t8);
			append(div8, t9);
			append(div8, div7);
			append(div7, div4);
			append(div7, t11);
			append(div7, div6);
			append(div6, input);
			set_input_value(input, /*amountToClaim*/ ctx[2]);
			append(div6, t12);
			append(div6, div5);
			append(div5, button0);
			append(div8, t14);
			append(div8, button1);
			append(button1, t15);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[26]),
					listen(button0, "click", /*click_handler_9*/ ctx[27]),
					listen(button1, "click", /*click_handler_10*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*pool*/ 8 && t3_value !== (t3_value = /*pool*/ ctx[3].rewards_token + "")) set_data(t3, t3_value);

			if (dirty[0] & /*pool, $balances*/ 24 && t6_value !== (t6_value = (/*pool*/ ctx[3].KeyUnipoolEarnedBalance
			? amountFormatter({
					amount: /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolEarnedBalance],
					displayDecimals: 16
				})
			: 0) + "")) set_data(t6, t6_value);

			if (dirty[0] & /*pool*/ 8 && t8_value !== (t8_value = /*pool*/ ctx[3].rewards_token + "")) set_data(t8, t8_value);

			if (dirty[0] & /*amountToClaim*/ 4 && input.value !== /*amountToClaim*/ ctx[2]) {
				set_input_value(input, /*amountToClaim*/ ctx[2]);
			}

			if (dirty[0] & /*$_*/ 512 && t15_value !== (t15_value = /*$_*/ ctx[9]("stake.claim") + "")) set_data(t15, t15_value);
		},
		d(detaching) {
			if (detaching) detach(div8);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (805:14) {#if pool.contractType === "Geyser"}
function create_if_block_13(ctx) {
	let div7;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let t2;
	let div1;
	let t4;
	let div2;
	let t5_value = /*geyserApy*/ ctx[7].earnedOptimistic + "";
	let t5;
	let t6;
	let t7_value = /*pool*/ ctx[3].rewards_token + "";
	let t7;
	let t8;
	let div6;
	let div4;
	let div3;
	let t9_value = /*$_*/ ctx[9]("general.amount") + "";
	let t9;
	let t10;
	let t11;
	let div5;
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			div7 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			div0.textContent = "REWARDS EARNED";
			t2 = space();
			div1 = element("div");
			div1.textContent = "Optimistic reward";
			t4 = space();
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			t7 = text(t7_value);
			t8 = space();
			div6 = element("div");
			div4 = element("div");
			div3 = element("div");
			t9 = text(t9_value);
			t10 = text(" accrued");
			t11 = space();
			div5 = element("div");
			input = element("input");
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.claim)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(div3, "class", "left float-left");
			attr(div4, "class", "top h-24px text-sm font-thin px-4 py-4 md:py-2");
			input.disabled = true;
			attr(input, "type", "text");
			attr(input, "class", "text-black font-thin text-base w-60pc md:w-75pc md:text-lg");
			attr(div5, "class", "bottom px-4 py-4 md:py-2");
			attr(div6, "class", "w-80 input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(div7, "class", "farming-card flex flex-col justify-center align-center items-center mx-1 my-4  border border-gray border-opacity-50 border-solid rounded-sm py-2");
		},
		m(target, anchor) {
			insert(target, div7, anchor);
			append(div7, img);
			append(div7, t0);
			append(div7, div0);
			append(div7, t2);
			append(div7, div1);
			append(div7, t4);
			append(div7, div2);
			append(div2, t5);
			append(div2, t6);
			append(div2, t7);
			append(div7, t8);
			append(div7, div6);
			append(div6, div4);
			append(div4, div3);
			append(div3, t9);
			append(div3, t10);
			append(div6, t11);
			append(div6, div5);
			append(div5, input);
			set_input_value(input, /*geyserApy*/ ctx[7].earnedOptimistic);

			if (!mounted) {
				dispose = listen(input, "input", /*input_input_handler_1*/ ctx[29]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*geyserApy*/ 128 && t5_value !== (t5_value = /*geyserApy*/ ctx[7].earnedOptimistic + "")) set_data(t5, t5_value);
			if (dirty[0] & /*pool*/ 8 && t7_value !== (t7_value = /*pool*/ ctx[3].rewards_token + "")) set_data(t7, t7_value);
			if (dirty[0] & /*$_*/ 512 && t9_value !== (t9_value = /*$_*/ ctx[9]("general.amount") + "")) set_data(t9, t9_value);

			if (dirty[0] & /*geyserApy*/ 128 && input.value !== /*geyserApy*/ ctx[7].earnedOptimistic) {
				set_input_value(input, /*geyserApy*/ ctx[7].earnedOptimistic);
			}
		},
		d(detaching) {
			if (detaching) detach(div7);
			mounted = false;
			dispose();
		}
	};
}

// (825:14) {#if $farming[pool.addressUniPoll] !== undefined}
function create_if_block_11(ctx) {
	let p0;
	let t0_value = /*$_*/ ctx[9]("stake.total.of") + "";
	let t0;
	let t1;
	let strong0;
	let t2_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalBPTAmount, 4) + "";
	let t2;
	let t3;
	let t4;
	let t5;
	let p1;
	let t6_value = /*$_*/ ctx[9]("stake.total") + "";
	let t6;
	let t7;
	let strong1;
	let t8_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalStakedBPTAmount, 4) + "";
	let t8;
	let t9;
	let t10;
	let t11_value = /*$_*/ ctx[9]("stake.staked.contract") + "";
	let t11;
	let t12;
	let if_block_anchor;
	let if_block = /*pool*/ ctx[3].KeyAddressTokenToStake && /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] && create_if_block_12(ctx);

	return {
		c() {
			p0 = element("p");
			t0 = text(t0_value);
			t1 = text("  : ");
			strong0 = element("strong");
			t2 = text(t2_value);
			t3 = text(" BPT ");
			t4 = text(".");
			t5 = space();
			p1 = element("p");
			t6 = text(t6_value);
			t7 = text("    : ");
			strong1 = element("strong");
			t8 = text(t8_value);
			t9 = text(" BPT");
			t10 = space();
			t11 = text(t11_value);
			t12 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			insert(target, p0, anchor);
			append(p0, t0);
			append(p0, t1);
			append(p0, strong0);
			append(strong0, t2);
			append(strong0, t3);
			append(p0, t4);
			insert(target, t5, anchor);
			insert(target, p1, anchor);
			append(p1, t6);
			append(p1, t7);
			append(p1, strong1);
			append(strong1, t8);
			append(strong1, t9);
			append(p1, t10);
			append(p1, t11);
			insert(target, t12, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 512 && t0_value !== (t0_value = /*$_*/ ctx[9]("stake.total.of") + "")) set_data(t0, t0_value);
			if (dirty[0] & /*$farming, pool*/ 264 && t2_value !== (t2_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalBPTAmount, 4) + "")) set_data(t2, t2_value);
			if (dirty[0] & /*$_*/ 512 && t6_value !== (t6_value = /*$_*/ ctx[9]("stake.total") + "")) set_data(t6, t6_value);
			if (dirty[0] & /*$farming, pool*/ 264 && t8_value !== (t8_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalStakedBPTAmount, 4) + "")) set_data(t8, t8_value);
			if (dirty[0] & /*$_*/ 512 && t11_value !== (t11_value = /*$_*/ ctx[9]("stake.staked.contract") + "")) set_data(t11, t11_value);

			if (/*pool*/ ctx[3].KeyAddressTokenToStake && /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_12(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(p0);
			if (detaching) detach(t5);
			if (detaching) detach(p1);
			if (detaching) detach(t12);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (828:16) {#if pool.KeyAddressTokenToStake && $balances[pool.KeyUnipoolBalance]}
function create_if_block_12(ctx) {
	let p;
	let t0;
	let strong;
	let t1_value = toFixed(/*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] * 100 / /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalStakedBPTAmount, 3) + "";
	let t1;
	let t2;
	let t3;
	let t4_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber(), 2) + "";
	let t4;
	let t5;
	let t6_value = /*pool*/ ctx[3].containing[0].symbol + "";
	let t6;
	let t7;
	let t8_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].WETHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber(), 2) + "";
	let t8;
	let t9;
	let t10_value = /*pool*/ ctx[3].containing[1].symbol + "";
	let t10;
	let t11;
	let t12_value = formatFiat((/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber() * /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHPrice + /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].WETHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber() * /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].ETHPrice).toFixed(2)) + "";
	let t12;

	return {
		c() {
			p = element("p");
			t0 = text("You are staking   : ");
			strong = element("strong");
			t1 = text(t1_value);
			t2 = text("%");
			t3 = text(" of the pool\n                          = [");
			t4 = text(t4_value);
			t5 = space();
			t6 = text(t6_value);
			t7 = text(", ");
			t8 = text(t8_value);
			t9 = space();
			t10 = text(t10_value);
			t11 = text("]\n                          = ");
			t12 = text(t12_value);
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, strong);
			append(strong, t1);
			append(strong, t2);
			append(p, t3);
			append(p, t4);
			append(p, t5);
			append(p, t6);
			append(p, t7);
			append(p, t8);
			append(p, t9);
			append(p, t10);
			append(p, t11);
			append(p, t12);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$balances, pool, $farming*/ 280 && t1_value !== (t1_value = toFixed(/*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance] * 100 / /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].totalStakedBPTAmount, 3) + "")) set_data(t1, t1_value);
			if (dirty[0] & /*$farming, pool, $balances*/ 280 && t4_value !== (t4_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber(), 2) + "")) set_data(t4, t4_value);
			if (dirty[0] & /*pool*/ 8 && t6_value !== (t6_value = /*pool*/ ctx[3].containing[0].symbol + "")) set_data(t6, t6_value);
			if (dirty[0] & /*$farming, pool, $balances*/ 280 && t8_value !== (t8_value = toFixed(/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].WETHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber(), 2) + "")) set_data(t8, t8_value);
			if (dirty[0] & /*pool*/ 8 && t10_value !== (t10_value = /*pool*/ ctx[3].containing[1].symbol + "")) set_data(t10, t10_value);
			if (dirty[0] & /*$farming, pool, $balances*/ 280 && t12_value !== (t12_value = formatFiat((/*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber() * /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].DOUGHPrice + /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].WETHperBPT * /*$balances*/ ctx[4][/*pool*/ ctx[3].KeyUnipoolBalance].toNumber() * /*$farming*/ ctx[8][/*pool*/ ctx[3].addressUniPoll].ETHPrice).toFixed(2)) + "")) set_data(t12, t12_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (836:14) {#if pool.contractType === "Geyser"}
function create_if_block_10(ctx) {
	let br;
	let t0;
	let p0;
	let t1;
	let strong0;
	let t2_value = /*geyserApy*/ ctx[7].yourStake.toFixed(2) + "";
	let t2;
	let t3;
	let t4;
	let strong1;
	let t5_value = /*geyserApy*/ ctx[7].earnedOptimistic + "";
	let t5;
	let t6;
	let t7;
	let t8;
	let p1;
	let t9;
	let strong2;
	let t10_value = /*geyserApy*/ ctx[7].apy + "";
	let t10;
	let t11;
	let t12;
	let t13;
	let p2;
	let t14;
	let strong3;
	let t15_value = /*geyserApy*/ ctx[7].earnedNotOptimistic + "";
	let t15;
	let t16;
	let t17;
	let strong4;
	let t18_value = /*geyserApy*/ ctx[7].apyNotOptimistic + "";
	let t18;
	let t19;
	let t20;

	return {
		c() {
			br = element("br");
			t0 = space();
			p0 = element("p");
			t1 = text("Your stake of ");
			strong0 = element("strong");
			t2 = text(t2_value);
			t3 = text(" BPT");
			t4 = text(" is earning right now ");
			strong1 = element("strong");
			t5 = text(t5_value);
			t6 = text(" CEPToken");
			t7 = text(" assuming you will not unstake until the end of the program.");
			t8 = space();
			p1 = element("p");
			t9 = text("Approx ");
			strong2 = element("strong");
			t10 = text(t10_value);
			t11 = text("%");
			t12 = text(".");
			t13 = space();
			p2 = element("p");
			t14 = text("If you would unstake right now, you would get exactly ");
			strong3 = element("strong");
			t15 = text(t15_value);
			t16 = text(" CEPToken");
			t17 = text(", which is approx ");
			strong4 = element("strong");
			t18 = text(t18_value);
			t19 = text("% APR");
			t20 = text(".");
		},
		m(target, anchor) {
			insert(target, br, anchor);
			insert(target, t0, anchor);
			insert(target, p0, anchor);
			append(p0, t1);
			append(p0, strong0);
			append(strong0, t2);
			append(strong0, t3);
			append(p0, t4);
			append(p0, strong1);
			append(strong1, t5);
			append(strong1, t6);
			append(p0, t7);
			insert(target, t8, anchor);
			insert(target, p1, anchor);
			append(p1, t9);
			append(p1, strong2);
			append(strong2, t10);
			append(strong2, t11);
			append(p1, t12);
			insert(target, t13, anchor);
			insert(target, p2, anchor);
			append(p2, t14);
			append(p2, strong3);
			append(strong3, t15);
			append(strong3, t16);
			append(p2, t17);
			append(p2, strong4);
			append(strong4, t18);
			append(strong4, t19);
			append(p2, t20);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*geyserApy*/ 128 && t2_value !== (t2_value = /*geyserApy*/ ctx[7].yourStake.toFixed(2) + "")) set_data(t2, t2_value);
			if (dirty[0] & /*geyserApy*/ 128 && t5_value !== (t5_value = /*geyserApy*/ ctx[7].earnedOptimistic + "")) set_data(t5, t5_value);
			if (dirty[0] & /*geyserApy*/ 128 && t10_value !== (t10_value = /*geyserApy*/ ctx[7].apy + "")) set_data(t10, t10_value);
			if (dirty[0] & /*geyserApy*/ 128 && t15_value !== (t15_value = /*geyserApy*/ ctx[7].earnedNotOptimistic + "")) set_data(t15, t15_value);
			if (dirty[0] & /*geyserApy*/ 128 && t18_value !== (t18_value = /*geyserApy*/ ctx[7].apyNotOptimistic + "")) set_data(t18, t18_value);
		},
		d(detaching) {
			if (detaching) detach(br);
			if (detaching) detach(t0);
			if (detaching) detach(p0);
			if (detaching) detach(t8);
			if (detaching) detach(p1);
			if (detaching) detach(t13);
			if (detaching) detach(p2);
		}
	};
}

// (634:20) {:else}
function create_else_block_2(ctx) {
	let div4;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let a;
	let t1_value = /*ammPool*/ ctx[39].name + "";
	let t1;
	let a_href_value;
	let t2;
	let div1;
	let t3_value = /*ammPool*/ ctx[39].description + "";
	let t3;
	let t4;
	let div2;
	let t5_value = /*ammPool*/ ctx[39].weeklyRewards + "";
	let t5;
	let t6;
	let t7_value = /*ammPool*/ ctx[39].rewards_token + "";
	let t7;
	let t8;
	let div3;
	let t9_value = /*ammPool*/ ctx[39].platform + "";
	let t9;
	let t10;
	let t11;
	let t12;

	function select_block_type_4(ctx, dirty) {
		if (/*ammPool*/ ctx[39].contractType === "Geyser") return create_if_block_5;
		return create_else_block_4;
	}

	let current_block_type = select_block_type_4(ctx, [-1]);
	let if_block0 = current_block_type(ctx);

	function select_block_type_6(ctx, dirty) {
		if (/*ammPool*/ ctx[39].enabled) return create_if_block_4;
		return create_else_block_3;
	}

	let current_block_type_1 = select_block_type_6(ctx, [-1]);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			div4 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			a = element("a");
			t1 = text(t1_value);
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			t7 = text(t7_value);
			t8 = space();
			div3 = element("div");
			t9 = text(t9_value);
			t10 = space();
			if_block0.c();
			t11 = space();
			if_block1.c();
			t12 = space();
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.logos.piedao_clean)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(a, "href", a_href_value = /*ammPool*/ ctx[39].poolLink);
			attr(a, "target", "_blank");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(div3, "class", "apy");
			attr(div4, "class", "farming-card flex flex-col justify-center align-center items-center text-center mx-2 my-2 md:m-2 border border-gray border-opacity-50 border-solid rounded-sm p-6");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, img);
			append(div4, t0);
			append(div4, div0);
			append(div0, a);
			append(a, t1);
			append(div4, t2);
			append(div4, div1);
			append(div1, t3);
			append(div4, t4);
			append(div4, div2);
			append(div2, t5);
			append(div2, t6);
			append(div2, t7);
			append(div4, t8);
			append(div4, div3);
			append(div3, t9);
			append(div4, t10);
			if_block0.m(div4, null);
			append(div4, t11);
			if_block1.m(div4, null);
			append(div4, t12);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*incentivizedPools*/ 64 && t1_value !== (t1_value = /*ammPool*/ ctx[39].name + "")) set_data(t1, t1_value);

			if (dirty[0] & /*incentivizedPools*/ 64 && a_href_value !== (a_href_value = /*ammPool*/ ctx[39].poolLink)) {
				attr(a, "href", a_href_value);
			}

			if (dirty[0] & /*incentivizedPools*/ 64 && t3_value !== (t3_value = /*ammPool*/ ctx[39].description + "")) set_data(t3, t3_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t5_value !== (t5_value = /*ammPool*/ ctx[39].weeklyRewards + "")) set_data(t5, t5_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t7_value !== (t7_value = /*ammPool*/ ctx[39].rewards_token + "")) set_data(t7, t7_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t9_value !== (t9_value = /*ammPool*/ ctx[39].platform + "")) set_data(t9, t9_value);

			if (current_block_type === (current_block_type = select_block_type_4(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div4, t11);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_6(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div4, t12);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div4);
			if_block0.d();
			if_block1.d();
		}
	};
}

// (614:20) {#if ammPool.highlight}
function create_if_block_1(ctx) {
	let div5;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let a0;
	let t1_value = /*ammPool*/ ctx[39].name + "";
	let t1;
	let a0_href_value;
	let t2;
	let div1;
	let t3_value = /*ammPool*/ ctx[39].description + "";
	let t3;
	let t4;
	let div2;
	let t5_value = /*ammPool*/ ctx[39].weeklyRewards + "";
	let t5;
	let t6;
	let t7_value = /*ammPool*/ ctx[39].rewards_token + "";
	let t7;
	let t8;
	let div3;
	let a1;
	let t9_value = /*ammPool*/ ctx[39].platform + "";
	let t9;
	let a1_href_value;
	let t10;
	let div4;
	let t11;
	let t12;

	function select_block_type_2(ctx, dirty) {
		if (/*$farming*/ ctx[8][/*ammPool*/ ctx[39].addressUniPoll] !== undefined) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_2(ctx, [-1]);
	let if_block0 = current_block_type(ctx);

	function select_block_type_3(ctx, dirty) {
		if (/*ammPool*/ ctx[39].enabled) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type_1 = select_block_type_3(ctx, [-1]);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			div5 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			a0 = element("a");
			t1 = text(t1_value);
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			div2 = element("div");
			t5 = text(t5_value);
			t6 = space();
			t7 = text(t7_value);
			t8 = space();
			div3 = element("div");
			a1 = element("a");
			t9 = text(t9_value);
			t10 = space();
			div4 = element("div");
			if_block0.c();
			t11 = space();
			if_block1.c();
			t12 = space();
			attr(img, "class", "h-40px w-40px mb-2 md:h-70px md:w-70px");
			if (img.src !== (img_src_value = images.logos.piedao_clean)) attr(img, "src", img_src_value);
			attr(img, "alt", "PieDAO logo");
			attr(a0, "href", a0_href_value = /*ammPool*/ ctx[39].poolLink);
			attr(a0, "target", "_blank");
			attr(div0, "class", "title text-lg");
			attr(div1, "class", "subtitle font-thin");
			attr(div2, "class", "apy");
			attr(a1, "href", a1_href_value = /*ammPool*/ ctx[39].poolLink);
			attr(a1, "target", "_blank");
			attr(div3, "class", "apy");
			attr(div4, "class", "apy");
			attr(div5, "class", "highlight-box farming-card flex flex-col justify-center align-center items-center text-center mx-2 my-2 md:m-2 border border-gray border-opacity-50 border-solid rounded-sm p-6");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, img);
			append(div5, t0);
			append(div5, div0);
			append(div0, a0);
			append(a0, t1);
			append(div5, t2);
			append(div5, div1);
			append(div1, t3);
			append(div5, t4);
			append(div5, div2);
			append(div2, t5);
			append(div2, t6);
			append(div2, t7);
			append(div5, t8);
			append(div5, div3);
			append(div3, a1);
			append(a1, t9);
			append(div5, t10);
			append(div5, div4);
			if_block0.m(div4, null);
			append(div5, t11);
			if_block1.m(div5, null);
			append(div5, t12);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*incentivizedPools*/ 64 && t1_value !== (t1_value = /*ammPool*/ ctx[39].name + "")) set_data(t1, t1_value);

			if (dirty[0] & /*incentivizedPools*/ 64 && a0_href_value !== (a0_href_value = /*ammPool*/ ctx[39].poolLink)) {
				attr(a0, "href", a0_href_value);
			}

			if (dirty[0] & /*incentivizedPools*/ 64 && t3_value !== (t3_value = /*ammPool*/ ctx[39].description + "")) set_data(t3, t3_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t5_value !== (t5_value = /*ammPool*/ ctx[39].weeklyRewards + "")) set_data(t5, t5_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t7_value !== (t7_value = /*ammPool*/ ctx[39].rewards_token + "")) set_data(t7, t7_value);
			if (dirty[0] & /*incentivizedPools*/ 64 && t9_value !== (t9_value = /*ammPool*/ ctx[39].platform + "")) set_data(t9, t9_value);

			if (dirty[0] & /*incentivizedPools*/ 64 && a1_href_value !== (a1_href_value = /*ammPool*/ ctx[39].poolLink)) {
				attr(a1, "href", a1_href_value);
			}

			if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div4, null);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div5, t12);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div5);
			if_block0.d();
			if_block1.d();
		}
	};
}

// (659:26) {:else}
function create_else_block_4(ctx) {
	let div;

	function select_block_type_5(ctx, dirty) {
		if (/*$farming*/ ctx[8][/*ammPool*/ ctx[39].addressUniPoll] !== undefined) return create_if_block_9;
		return create_else_block_5;
	}

	let current_block_type = select_block_type_5(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "apy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_5(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

// (642:26) {#if ammPool.contractType === 'Geyser'}
function create_if_block_5(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let if_block2_anchor;
	let if_block0 = /*geyserApy*/ ctx[7].loaded === false && create_if_block_8(ctx);
	let if_block1 = /*geyserApy*/ ctx[7].loaded && /*geyserApy*/ ctx[7].yourStake > 0 && create_if_block_7(ctx);
	let if_block2 = /*geyserApy*/ ctx[7].loaded && /*geyserApy*/ ctx[7].yourStake == 0 && create_if_block_6(ctx);

	return {
		c() {
			div = element("div");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			set_style(div, "position", "absolute");
			set_style(div, "top", "10px");
			set_style(div, "right", "10px");
			attr(div, "class", "apy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			insert(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t2, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, if_block2_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*geyserApy*/ ctx[7].loaded === false) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*geyserApy*/ ctx[7].loaded && /*geyserApy*/ ctx[7].yourStake > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(t2.parentNode, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*geyserApy*/ ctx[7].loaded && /*geyserApy*/ ctx[7].yourStake == 0) {
				if (if_block2) {
					
				} else {
					if_block2 = create_if_block_6(ctx);
					if_block2.c();
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t2);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (663:30) {:else}
function create_else_block_5(ctx) {
	let t;

	return {
		c() {
			t = text("n/a");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (661:30) {#if $farming[ammPool.addressUniPoll] !== undefined}
function create_if_block_9(ctx) {
	let t_value = /*$farming*/ ctx[8][/*ammPool*/ ctx[39].addressUniPoll].apr + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$farming, incentivizedPools*/ 320 && t_value !== (t_value = /*$farming*/ ctx[8][/*ammPool*/ ctx[39].addressUniPoll].apr + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (647:28) {#if geyserApy.loaded === false}
function create_if_block_8(ctx) {
	let t;

	return {
		c() {
			t = text("Loading ");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (651:28) {#if geyserApy.loaded && geyserApy.yourStake > 0}
function create_if_block_7(ctx) {
	let div;
	let t0_value = /*geyserApy*/ ctx[7].apy + "";
	let t0;
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = text(" %");
			attr(div, "class", "apy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*geyserApy*/ 128 && t0_value !== (t0_value = /*geyserApy*/ ctx[7].apy + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (655:28) {#if geyserApy.loaded && geyserApy.yourStake == 0}
function create_if_block_6(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = "You are not staking";
			attr(div, "class", "apy");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (672:26) {:else}
function create_else_block_3(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			button.textContent = "Oct 3rd, 6:00pm UTC";
			button.disabled = true;
			attr(button, "class", "btn border-white clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (669:26) {#if ammPool.enabled}
function create_if_block_4(ctx) {
	let input;
	let t0;
	let button;
	let t1_value = /*$_*/ ctx[9]("general.select") + "";
	let t1;
	let mounted;
	let dispose;

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[16](/*ammPool*/ ctx[39], ...args);
	}

	return {
		c() {
			input = element("input");
			t0 = space();
			button = element("button");
			t1 = text(t1_value);
			attr(input, "type", "hidden");
			input.value = /*pool*/ ctx[3];
			attr(button, "class", "btn clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			insert(target, t0, anchor);
			insert(target, button, anchor);
			append(button, t1);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*pool*/ 8) {
				input.value = /*pool*/ ctx[3];
			}

			if (dirty[0] & /*$_*/ 512 && t1_value !== (t1_value = /*$_*/ ctx[9]("general.select") + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(input);
			if (detaching) detach(t0);
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (624:32) {:else}
function create_else_block_1(ctx) {
	let t;

	return {
		c() {
			t = text("n/a");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (622:32) {#if $farming[ammPool.addressUniPoll] !== undefined}
function create_if_block_3(ctx) {
	let t_value = /*$farming*/ ctx[8][/*ammPool*/ ctx[39].addressUniPoll].apr + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$farming, incentivizedPools*/ 320 && t_value !== (t_value = /*$farming*/ ctx[8][/*ammPool*/ ctx[39].addressUniPoll].apr + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (630:28) {:else}
function create_else_block(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			button.textContent = "Oct 3rd, 6:00pm UTC";
			button.disabled = true;
			attr(button, "class", "btn border-white clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
		}
	};
}

// (628:28) {#if ammPool.enabled}
function create_if_block_2(ctx) {
	let button;
	let t_value = /*$_*/ ctx[9]("general.select") + "";
	let t;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[15](/*ammPool*/ ctx[39], ...args);
	}

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "class", "btn border-white clear font-bold ml-1 mr-0 rounded md:mr-4 py-2 px-4");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*$_*/ 512 && t_value !== (t_value = /*$_*/ ctx[9]("general.select") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (613:16) {#each filter(incentivizedPools, {deprecated: false}) as ammPool}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*ammPool*/ ctx[39].highlight) return create_if_block_1;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_1(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let img0;
	let img0_src_value;
	let t0;
	let img1;
	let img1_src_value;
	let t1;
	let div0;

	function select_block_type(ctx, dirty) {
		if (!/*pool*/ ctx[3]) return create_if_block;
		return create_else_block_6;
	}

	let current_block_type = select_block_type(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div1 = element("div");
			img0 = element("img");
			t0 = space();
			img1 = element("img");
			t1 = space();
			div0 = element("div");
			if_block.c();
			attr(img0, "class", "banner-desktop");
			if (img0.src !== (img0_src_value = "images/banner.png")) attr(img0, "src", img0_src_value);
			attr(img1, "class", "banner-mobile");
			if (img1.src !== (img1_src_value = "https://raw.githubusercontent.com/pie-dao/brand/master/misc/amazingrewards4-mobile.png")) attr(img1, "src", img1_src_value);
			attr(div0, "class", "liquidity-container flex flex-col align-center bg-grey-243 rounded-4px p-4 my-0 md:p-6 w-full");
			attr(div1, "class", "content flex flex-col");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, img0);
			append(div1, t0);
			append(div1, img1);
			append(div1, t1);
			append(div1, div0);
			if_block.m(div0, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div0, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
			if_block.d();
		}
	};
}

let ethBalance = 0;

function instance($$self, $$props, $$invalidate) {
	let $balances;
	let $currentRoute;
	let $eth;
	let $farming;
	let $_;
	component_subscribe($$self, balances, $$value => $$invalidate(4, $balances = $$value));
	component_subscribe($$self, currentRoute, $$value => $$invalidate(32, $currentRoute = $$value));
	component_subscribe($$self, eth, $$value => $$invalidate(33, $eth = $$value));
	component_subscribe($$self, farming, $$value => $$invalidate(8, $farming = $$value));
	component_subscribe($$self, _, $$value => $$invalidate(9, $_ = $$value));
	const isAddress = thing => thing && ethers.utils.isHexString(thing) && thing.length === 42;
	let ethKey;
	let intiated = false;
	let amountToStake = 0;
	let amountToUnstake = 0;
	let isReady = false;
	const referral = $currentRoute.params.referral || window.localStorage.getItem("referral");

	const estimateUnstake = async () => {
		const { provider, signer } = get(eth);
		let contract = new ethers.Contract("0xb3c2b0056627cc1dc148d8fc29f5abdf4dd837bc", geyserABI, provider);
		let overrides = { from: $eth.address };
		let data = await contract.callStatic.updateAccounting(overrides);
		let loaded = false;
		let _totalStakingShareSeconds = data[3];
		let stakingShareSeconds = data[2];
		let totalUnlocked = data[1];
		let _pool = incentivizedPools[2];
		let apy8Wweeks = 0;
		let apy = 0;
		let rewardsPerBPT = 0;
		let $RewardsPerBPT = 0;
		let days60APY = 0;
		let apyV2 = 0;
		let apyV2NotOptimistic = 0;
		let yourStake = 0;
		let seconds = BigNumber(0);
		let rewardPerSecond = 0;
		let rewardPerWeek = 0;
		let rewardPer8Week = 0;
		let unstakeNowRewards = 0;
		let totalUserRewards = totalUnlocked.mul(stakingShareSeconds).div(_totalStakingShareSeconds);
		let earnedOptimistic = BigNumber(totalUserRewards.toString()).dividedBy(10 ** 18);
		let tokenStakedPrice = 0;
		let DOUGHPrice = 0;
		let BPTPrice = 0;

		if ($balances[_pool.KeyUnipoolBalance] && $farming[_pool.addressUniPoll] !== undefined) {
			DOUGHPrice = $farming[incentivizedPools[0].addressUniPoll] && $farming[incentivizedPools[0].addressUniPoll].DOUGHPrice
			? $farming[incentivizedPools[0].addressUniPoll].DOUGHPrice
			: 0;

			BPTPrice = $farming[_pool.addressUniPoll].BPTPrice || 0;
			tokenStakedPrice = $farming[_pool.addressUniPoll].DOUGHPrice || 0;
			const amount = ethers.BigNumber.from(BigNumber($balances[_pool.KeyUnipoolBalance].toString()).multipliedBy(10 ** 18).toFixed(0));
			unstakeNowRewards = await contract.callStatic.unstakeQuery(amount, overrides);
			unstakeNowRewards = BigNumber(unstakeNowRewards.toString()).dividedBy(10 ** 18).toNumber();
			seconds = BigNumber(stakingShareSeconds.toString()).dividedBy(BigNumber($balances[_pool.KeyUnipoolBalance].toString()).multipliedBy(10 ** 18)).dividedBy(1000).dividedBy(1000);
			yourStake = $balances[_pool.KeyUnipoolBalance].toNumber();
			rewardsPerBPT = earnedOptimistic.toNumber() / yourStake;
			$RewardsPerBPT = rewardsPerBPT * DOUGHPrice;
			let rewardsPerBPTNotOptimistic = unstakeNowRewards / yourStake;
			let $RewardsPerBPTNotOptimistic = rewardsPerBPTNotOptimistic * DOUGHPrice;
			let days60APYNotOptimistic = $RewardsPerBPTNotOptimistic * 100 / BPTPrice;
			days60APY = $RewardsPerBPT * 100 / BPTPrice;
			apyV2 = days60APY * (31536000 / seconds.toNumber());
			apyV2NotOptimistic = days60APYNotOptimistic * (31536000 / seconds.toNumber());
			loaded = true;
		}

		$$invalidate(7, geyserApy = {
			BPTPrice,
			rewardsPerBPT,
			DOUGHPrice,
			seconds: seconds.toNumber(),
			earnedOptimistic: earnedOptimistic.toFixed(4),
			earnedNotOptimistic: unstakeNowRewards.toFixed(4),
			yourStake,
			apy: apyV2.toFixed(2),
			apyNotOptimistic: apyV2NotOptimistic.toFixed(2),
			totalStakingShareSeconds: _totalStakingShareSeconds.toString(),
			stakingShareSeconds: stakingShareSeconds.toString(),
			totalUnlocked: totalUnlocked.toString(),
			totalUserRewards: earnedOptimistic.toString(),
			$RewardsPerBPT,
			loaded
		});

		console.log("geyserApy", geyserApy);
		return earnedOptimistic;
	};

	window.addEventListener(
		"price-update",
		async function (e) {
			console.log("price-update", e);
			$$invalidate(31, isReady = true);

			incentivizedPools.forEach(async pool => {
				if (pool.type === "UniswapV2") {
					await calculateAPRUniswap(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
				} else {
					await calculateAPRBalancer(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
				}
			});

			await estimateUnstake();
		},
		false
	);

	const needApproval = (pool, allowance) => {
		if (allowance.isEqualTo(0)) return true;
		if (allowance.isGreaterThanOrEqualTo(BigNumber(amountToStake))) return false;
	};

	const action = async (pool, actionType) => {
		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const { addressTokenToStake, addressUniPoll } = pool;

		if (actionType === "unlock") {
			await approveMax(addressTokenToStake, addressUniPoll);
			$$invalidate(5, needAllowance = false);
		}
	};

	const unstake = async () => {
		if (amountToUnstake === 0) {
			displayNotification({ message: "Amount is zero", type: "hint" });
			return;
		}

		let requestedAmount = BigNumber(amountToUnstake);
		const max = $balances[pool.KeyUnipoolBalance];

		if (requestedAmount.isGreaterThan(max)) {
			requestedAmount = max;
			$$invalidate(1, amountToUnstake = max.toNumber());

			displayNotification({
				message: "Amount set to max",
				type: "hint"
			});
		}

		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		let unipool;
		let emitterToUse;
		const amountWei = requestedAmount.multipliedBy(10 ** 18).toFixed(0);

		if (pool.contractType === "UniPool") {
			unipool = await contract({
				address: pool.addressUniPoll,
				abi: recipeUnipool
			});

			const { emitter } = displayNotification(await unipool.withdraw(amountWei));
			emitterToUse = emitter;
		} else {
			unipool = await contract({
				address: pool.addressUniPoll,
				abi: geyserABI
			});

			const { emitter } = displayNotification(await unipool.unstake(amountWei, 0));
			emitterToUse = emitter;
		}

		emitterToUse.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} unstaked successfully`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const exit = async () => {
		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const unipool = await contract({
			address: pool.addressUniPoll,
			abi: recipeUnipool
		});

		const { emitter } = displayNotification(await unipool.exit());

		emitter.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `You claimed and unstaked`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const stake = async () => {
		if (amountToStake === 0) {
			displayNotification({ message: "Amount it zero", type: "hint" });
			return;
		}

		let requestedAmount = BigNumber(amountToStake);
		const max = $balances[pool.KeyAddressTokenToStake];
		let referralValidated = "0x4efD8CEad66bb0fA64C8d53eBE65f31663199C6d"; //Agent address

		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		if (requestedAmount.isGreaterThan(max)) {
			requestedAmount = max;
			$$invalidate(0, amountToStake = max.toNumber());

			displayNotification({
				message: "Amount set to max",
				type: "hint"
			});
		}

		if (referral && isAddress(referral) && referral.toLowerCase() !== $eth.address.toLowerCase()) {
			console.log("Im setting the referral to " + referral);
			referralValidated = referral;
		}

		const amountWei = requestedAmount.multipliedBy(10 ** 18).toFixed(0);
		let unipool;
		let emitterToUse;

		if (pool.contractType === "UniPool") {
			unipool = await contract({
				address: pool.addressUniPoll,
				abi: recipeUnipool
			});

			console.log(`Staking ${amountToStake} ${pool.toStakeSymbol} with referral ${referralValidated}`);
			const { emitter } = displayNotification(await unipool["stake(uint256,address)"](amountWei, referralValidated));
			emitterToUse = emitter;
		} else {
			unipool = await contract({
				address: pool.addressUniPoll,
				abi: geyserABI
			});

			const { emitter } = displayNotification(await unipool["stake(uint256)"](amountWei));
			emitterToUse = emitter;
		}

		emitterToUse.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} staked successfully`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const getRewards = async () => {
		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const unipool = await contract({
			address: pool.addressUniPoll,
			abi: recipeUnipool
		});

		const { emitter } = displayNotification(await unipool.getReward());

		emitter.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} staked successfully`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const click_handler = ammPool => $$invalidate(3, pool = ammPool);
	const click_handler_1 = ammPool => $$invalidate(3, pool = ammPool);
	const click_handler_2 = () => $$invalidate(3, pool = null);
	const click_handler_3 = () => exit();

	function input0_input_handler() {
		amountToUnstake = this.value;
		$$invalidate(1, amountToUnstake);
	}

	const click_handler_4 = () => {
		if ($balances[pool.KeyUnipoolBalance]) {
			$$invalidate(1, amountToUnstake = $balances[pool.KeyUnipoolBalance]);
		} else {
			$$invalidate(1, amountToUnstake = 0);
		}
	};

	const click_handler_5 = () => unstake();

	function input1_input_handler() {
		amountToStake = this.value;
		$$invalidate(0, amountToStake);
	}

	const click_handler_6 = () => {
		if ($balances[pool.KeyAddressTokenToStake]) {
			$$invalidate(0, amountToStake = $balances[pool.KeyAddressTokenToStake]);
		} else {
			$$invalidate(0, amountToStake = 0);
		}
	};

	const click_handler_7 = () => action(pool, "unlock");
	const click_handler_8 = () => stake();

	function input_input_handler() {
		amountToClaim = this.value;
		(($$invalidate(2, amountToClaim), $$invalidate(3, pool)), $$invalidate(4, $balances));
	}

	const click_handler_9 = () => {
		if ($balances[pool.KeyUnipoolEarnedBalance]) {
			$$invalidate(2, amountToClaim = $balances[pool.KeyUnipoolEarnedBalance].toFixed(4, BigNumber.ROUND_DOWN));
		} else {
			$$invalidate(2, amountToClaim = 0);
		}
	};

	const click_handler_10 = () => getRewards();

	function input_input_handler_1() {
		geyserApy.earnedOptimistic = this.value;
		$$invalidate(7, geyserApy);
	}

	let amountToClaim;
	let needAllowance;
	let incentivizedPools;
	let pool;
	let geyserApy;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*pool, $balances*/ 24) {
			$: $$invalidate(2, amountToClaim = pool && $balances[pool.KeyUnipoolEarnedBalance]
			? $balances[pool.KeyUnipoolEarnedBalance]
			: "0.00000000");
		}

		if ($$self.$$.dirty[0] & /*incentivizedPools, intiated*/ 1073741888 | $$self.$$.dirty[1] & /*$eth, isReady*/ 5) {
			$: if ($eth.address) {
				if (isReady) {
					incentivizedPools.forEach(async pool => {
						if (pool.type === "UniswapV2") {
							await calculateAPRUniswap(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
						}

						if (pool.type === "Balancer" && pool.contractType === "UniPool") {
							await calculateAPRBalancer(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
						}

						if (pool.type === "Balancer" && pool.contractType === "Geyser") {
							await calculateAPRBalancer(pool.addressUniPoll, pool.addressTokenToStake, null, null, pool.containing[0].address, pool.containing[1].address);
							await estimateUnstake();
						}
					});
				}

				if (!intiated) {
					const address = $eth.address;

					incentivizedPools.forEach(async p => {
						try {
							calculateAPRBalancer();
							subscribeToBalance(p.addressTokenToStake, address, true);
							subscribeToStaking(p.addressUniPoll, address, true);
							subscribeToAllowance(p.addressTokenToStake, address, p.addressUniPoll);
							p.allowanceKey = functionKey(p.addressTokenToStake, "allowance", [address, p.addressUniPoll]);
							p.KeyAddressTokenToStake = balanceKey(p.addressTokenToStake, address);

							if (p.contractType === "UniPool") {
								subscribeToStakingEarnings(p.addressUniPoll, address, true);
								p.KeyUnipoolBalance = balanceKey(p.addressUniPoll, address);
								p.KeyUnipoolEarnedBalance = balanceKey(p.addressUniPoll, address, ".earned");
							} else {
								console.log("Getting staked balance from geyser");
								console.log(p.addressUniPoll, "address");
								subscribeToStakingEarningsGeyser(p.addressUniPoll, address, true);
								p.KeyUnipoolBalance = balanceKey(p.addressUniPoll, address);
								await estimateUnstake();
							}
						} catch(e) {
							console.log(e);
						}
					});

					$$invalidate(30, intiated = true);
					bumpLifecycle();
				}
			}
		}
	};

	$: $$invalidate(3, pool = null);
	$: $$invalidate(5, needAllowance = true);

	$: $$invalidate(6, incentivizedPools = [
		{
			addressTokenToStake: "0xFAE2809935233d4BfE8a56c2355c4A2e7d1fFf1A",
			addressUniPoll: "0x8314337d2b13e1A61EadF0FD1686b2134D43762F",
			aprEnabled: true,
			deprecated: false,
			poolLink: "https://pools.balancer.exchange/#/pool/0xfae2809935233d4bfe8a56c2355c4a2e7d1fff1a/",
			name: "CEPToken / ETH",
			platform: " Balancer",
			description: "WEEKLY REWARDS",
			rewards_token: "CEPToken",
			weeklyRewards: formatFiat(110000, ",", ".", ""),
			apy: 1.8,
			toStakeSymbol: "BPT",
			toStakeDesc: "Balancer: CEPToken/ETH 80/20",
			allowance: 0,
			type: "Balancer",
			contractType: "UniPool",
			containing: [
				{
					symbol: "CEPToken",
					address: "0xad32A8e6220741182940c5aBF610bDE99E737b2D",
					balance: "0",
					icon: getTokenImage("0xad32A8e6220741182940c5aBF610bDE99E737b2D")
				},
				{
					symbol: "ETH",
					address: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
					balance: "0",
					icon: getTokenImage("eth")
				}
			],
			allowanceKey: "",
			highlight: true,
			needAllowance: true,
			enabled: true
		},
		{
			addressTokenToStake: "0x35333CF3Db8e334384EC6D2ea446DA6e445701dF",
			aprEnabled: true,
			deprecated: false,
			addressUniPoll: "0x220f25C2105a65425913FE0CF38e7699E3992B97",
			poolLink: "https://pools.balancer.exchange/#/pool/0x35333cf3db8e334384ec6d2ea446da6e445701df/",
			name: "DEFI+S / ETH",
			type: "Balancer",
			contractType: "UniPool",
			containing: [
				{
					symbol: "DEFI+S",
					address: "0xad6a626ae2b43dcb1b39430ce496d2fa0365ba9c",
					balance: "0",
					icon: getTokenImage("0xad6a626ae2b43dcb1b39430ce496d2fa0365ba9c")
				},
				{
					symbol: "ETH",
					address: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
					balance: "0",
					icon: getTokenImage("eth")
				}
			],
			rewards_token: "CEPToken",
			toStakeSymbol: "BPT",
			toStakeDesc: "Balancer: DEFI+S/ETH 70/30",
			platform: " Balancer",
			description: "WEEKLY REWARDS",
			weeklyRewards: formatFiat(20000, ",", ".", ""),
			apy: 1.8,
			allowance: 0,
			allowanceKey: "",
			needAllowance: true,
			enabled: true
		},
		{
			addressTokenToStake: "0xa795600590a7da0057469049ab8f1284baed977e",
			aprEnabled: false,
			deprecated: false,
			addressUniPoll: "0xb3c2b0056627cc1dc148d8fc29f5abdf4dd837bc",
			poolLink: "https://pools.balancer.exchange/#/pool/0xa795600590a7da0057469049ab8f1284baed977e/",
			name: "DEFI+L/ETH",
			type: "Balancer",
			contractType: "Geyser",
			containing: [
				{
					symbol: "DEFI+L",
					address: "0x78f225869c08d478c34e5f645d07a87d3fe8eb78",
					balance: "0",
					icon: getTokenImage("0x78f225869c08d478c34e5f645d07a87d3fe8eb78")
				},
				{
					symbol: "ETH",
					address: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
					balance: "0",
					icon: getTokenImage("eth")
				}
			],
			rewards_token: "CEPToken",
			toStakeSymbol: "BPT",
			toStakeDesc: "Balancer: DEFI+L/ETH 70/30",
			platform: " Balancer",
			description: "WEEKLY REWARDS",
			weeklyRewards: formatFiat(20000, ",", ".", ""),
			apy: 1.8,
			allowance: 0,
			allowanceKey: "",
			needAllowance: true,
			enabled: true
		},
		{
			addressTokenToStake: "0x7aeFaF3ea1b465dd01561B0548c9FD969e3F76BA",
			aprEnabled: true,
			deprecated: true,
			addressUniPoll: "0x64964cb69f40A1B56AF76e32Eb5BF2e2E52a747c",
			name: "DEFI+S / DAI",
			poolLink: "https://app.uniswap.org/#/add/0x6B175474E89094C44Da98b954EedeAC495271d0F/0xaD6A626aE2B43DCb1B39430Ce496d2FA0365BA9C",
			platform: " Uniswap",
			contractType: "UniPool",
			containing: [
				{
					symbol: "DEFI+S",
					address: "0xad6a626ae2b43dcb1b39430ce496d2fa0365ba9c",
					balance: "0",
					icon: getTokenImage("0xad6a626ae2b43dcb1b39430ce496d2fa0365ba9c")
				},
				{
					symbol: "DAI",
					address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
					balance: "0",
					icon: getTokenImage("0x6B175474E89094C44Da98b954EedeAC495271d0F")
				}
			],
			type: "UniswapV2",
			toStakeDesc: "Uniswap: DEFI+S/DAI 50/50",
			toStakeSymbol: "LP",
			description: "DEPRECATED POOL",
			rewards_token: "CEPToken",
			weeklyRewards: formatFiat(25000, ",", ".", ""),
			apy: 1.8,
			allowance: 0,
			allowanceKey: "",
			needAllowance: true,
			enabled: true
		}
	]);

	$: $$invalidate(7, geyserApy = { apy: 0, loaded: false });

	return [
		amountToStake,
		amountToUnstake,
		amountToClaim,
		pool,
		$balances,
		needAllowance,
		incentivizedPools,
		geyserApy,
		$farming,
		$_,
		action,
		unstake,
		exit,
		stake,
		getRewards,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		input0_input_handler,
		click_handler_4,
		click_handler_5,
		input1_input_handler,
		click_handler_6,
		click_handler_7,
		click_handler_8,
		input_input_handler,
		click_handler_9,
		click_handler_10,
		input_input_handler_1
	];
}

class LPStaking extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {}, [-1, -1]);
	}
}

export default LPStaking;