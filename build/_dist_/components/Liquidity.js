/* src/components/Liquidity.svelte generated by Svelte v3.29.0 */
import {
	SvelteComponent,
	append,
	attr,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	space,
	text,
	to_number,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import { onMount } from "../../web_modules/svelte.js";
import BigNumber from "../../web_modules/bignumberjs.js";
import debounce from "../../web_modules/lodash/debounce.js";
import { _ } from "../../web_modules/svelte-i18n.js";
import { ethers } from "../../web_modules/ethers.js";
import { pieSmartPool, erc20 } from "../../web_modules/@pie-dao/abis.js";
import images from "../config/images.json.proxy.js";
import poolsConfig from "../config/pools.json.proxy.js";
import recipeAbi from "../config/recipeABI.json.proxy.js";
import displayNotification from "../notifications.js";
import TokenSelectModal from "./TokenSelectModal.js";

import {
	allowances,
	approveMax,
	balanceKey,
	balances,
	connectWeb3,
	contract,
	eth,
	pools,
	bumpLifecycle,
	subject
} from "../stores/eth.js";

import {
	amountFormatter,
	fetchCalcTokensForAmounts,
	fetchPieTokens,
	fetchPooledTokens,
	maxAmount,
	getTokenImage,
	fetchEthBalance,
	fetchCalcToPie
} from "./helpers.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[47] = list[i];
	return child_ctx;
}

// (388:4) {:else}
function create_else_block_4(ctx) {
	let t_value = /*$_*/ ctx[14]("general.withdraw") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t_value !== (t_value = /*$_*/ ctx[14]("general.withdraw") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (386:4) {#if approach === 'add'}
function create_if_block_15(ctx) {
	let t0_value = /*$_*/ ctx[14]("general.add") + "";
	let t0;
	let t1;
	let t2_value = /*$_*/ ctx[14]("general.liquidity") + "";
	let t2;

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t0_value !== (t0_value = /*$_*/ ctx[14]("general.add") + "")) set_data(t0, t0_value);
			if (dirty[0] & /*$_*/ 16384 && t2_value !== (t2_value = /*$_*/ ctx[14]("general.liquidity") + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

// (416:2) {#if type === 'single'}
function create_if_block_14(ctx) {
	let div;
	let t0_value = /*$_*/ ctx[14]("pool.word1") + "";
	let t0;
	let t1;
	let br;
	let t2;
	let t3_value = /*$_*/ ctx[14]("pool.word2") + "";
	let t3;
	let t4;
	let strong;
	let t5_value = /*$_*/ ctx[14]("pool.strong") + "";
	let t5;
	let t6;
	let t7_value = /*$_*/ ctx[14]("pool.word3") + "";
	let t7;

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			br = element("br");
			t2 = space();
			t3 = text(t3_value);
			t4 = space();
			strong = element("strong");
			t5 = text(t5_value);
			t6 = space();
			t7 = text(t7_value);
			attr(div, "class", "text-left md:my-16px md:mx-20px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
			append(div, br);
			append(div, t2);
			append(div, t3);
			append(div, t4);
			append(div, strong);
			append(strong, t5);
			append(div, t6);
			append(div, t7);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t0_value !== (t0_value = /*$_*/ ctx[14]("pool.word1") + "")) set_data(t0, t0_value);
			if (dirty[0] & /*$_*/ 16384 && t3_value !== (t3_value = /*$_*/ ctx[14]("pool.word2") + "")) set_data(t3, t3_value);
			if (dirty[0] & /*$_*/ 16384 && t5_value !== (t5_value = /*$_*/ ctx[14]("pool.strong") + "")) set_data(t5, t5_value);
			if (dirty[0] & /*$_*/ 16384 && t7_value !== (t7_value = /*$_*/ ctx[14]("pool.word3") + "")) set_data(t7, t7_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (424:2) {#if type === 'multi'}
function create_if_block_11(ctx) {
	let t0;
	let t1;
	let t2;
	let if_block1_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*approach*/ ctx[3] === "add") return create_if_block_13;
		return create_else_block_3;
	}

	let current_block_type = select_block_type_1(ctx, [-1]);
	let if_block0 = current_block_type(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*approach*/ ctx[3] === "add") return create_if_block_12;
		return create_else_block_2;
	}

	let current_block_type_1 = select_block_type_2(ctx, [-1]);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			if_block0.c();
			t0 = space();
			t1 = text(/*tokenSymbol*/ ctx[9]);
			t2 = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			}

			if (dirty[0] & /*tokenSymbol*/ 512) set_data(t1, /*tokenSymbol*/ ctx[9]);

			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			}
		},
		d(detaching) {
			if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (427:4) {:else}
function create_else_block_3(ctx) {
	let t_value = /*$_*/ ctx[14]("piedao.multi.asset.enables.withdraw") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t_value !== (t_value = /*$_*/ ctx[14]("piedao.multi.asset.enables.withdraw") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (425:4) {#if approach === 'add'}
function create_if_block_13(ctx) {
	let t_value = /*$_*/ ctx[14]("piedao.multi.asset.enables.minting") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t_value !== (t_value = /*$_*/ ctx[14]("piedao.multi.asset.enables.minting") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (435:4) {:else}
function create_else_block_2(ctx) {
	let t_value = /*$_*/ ctx[14]("piedao.multi.asset.all.underlying") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t_value !== (t_value = /*$_*/ ctx[14]("piedao.multi.asset.all.underlying") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (433:4) {#if approach === 'add'}
function create_if_block_12(ctx) {
	let t_value = /*$_*/ ctx[14]("piedao.multi.asset.according.to.allocation") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t_value !== (t_value = /*$_*/ ctx[14]("piedao.multi.asset.according.to.allocation") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (442:2) {#if type === 'multi'}
function create_if_block_10(ctx) {
	let div2;
	let div0;
	let t0_value = /*$_*/ ctx[14]("general.add") + "";
	let t0;
	let t1;
	let t2_value = /*$_*/ ctx[14]("general.liquidity") + "";
	let t2;
	let div0_class_value;
	let t3;
	let div1;
	let t4_value = /*$_*/ ctx[14]("general.withdraw") + "";
	let t4;
	let div1_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			div1 = element("div");
			t4 = text(t4_value);
			attr(div0, "class", div0_class_value = "toggle-btn bg-grey-243 p-20px w-50pc text-center " + (/*approach*/ ctx[3] === "add" ? "active" : ""));
			attr(div1, "class", div1_class_value = "toggle-btn bg-grey-243 text-center p-20px w-50pc " + (/*approach*/ ctx[3] === "withdraw" ? "active" : ""));
			attr(div2, "class", "row bg-white mx-0 md:mx-4 flex mb-32px font-thin pointer border border-solid rounded-sm overflow-hidden border-gray-400");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, t0);
			append(div0, t1);
			append(div0, t2);
			append(div2, t3);
			append(div2, div1);
			append(div1, t4);

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*click_handler_1*/ ctx[23]),
					listen(div1, "click", /*click_handler_2*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t0_value !== (t0_value = /*$_*/ ctx[14]("general.add") + "")) set_data(t0, t0_value);
			if (dirty[0] & /*$_*/ 16384 && t2_value !== (t2_value = /*$_*/ ctx[14]("general.liquidity") + "")) set_data(t2, t2_value);

			if (dirty[0] & /*approach*/ 8 && div0_class_value !== (div0_class_value = "toggle-btn bg-grey-243 p-20px w-50pc text-center " + (/*approach*/ ctx[3] === "add" ? "active" : ""))) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty[0] & /*$_*/ 16384 && t4_value !== (t4_value = /*$_*/ ctx[14]("general.withdraw") + "")) set_data(t4, t4_value);

			if (dirty[0] & /*approach*/ 8 && div1_class_value !== (div1_class_value = "toggle-btn bg-grey-243 text-center p-20px w-50pc " + (/*approach*/ ctx[3] === "withdraw" ? "active" : ""))) {
				attr(div1, "class", div1_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div2);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (449:2) {#if type === 'multi'}
function create_if_block_8(ctx) {
	let div4;
	let div1;
	let div0;
	let t0_value = /*$_*/ ctx[14]("general.amount") + "";
	let t0;
	let t1;
	let t2;
	let div3;
	let input;
	let t3;
	let div2;
	let img;
	let img_src_value;
	let t4;
	let span;
	let t5;
	let t6;
	let tokenselectmodal;
	let current;
	let mounted;
	let dispose;
	let if_block = /*approach*/ ctx[3] === "withdraw" && create_if_block_9(ctx);

	tokenselectmodal = new TokenSelectModal({
			props: {
				tokens: /*pieTokens*/ ctx[8],
				open: /*tokenSelectModalOpen*/ ctx[1],
				callback: /*tokenSelectCallback*/ ctx[15]
			}
		});

	return {
		c() {
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			div3 = element("div");
			input = element("input");
			t3 = space();
			div2 = element("div");
			img = element("img");
			t4 = space();
			span = element("span");
			t5 = text(/*tokenSymbol*/ ctx[9]);
			t6 = space();
			create_component(tokenselectmodal.$$.fragment);
			attr(div0, "class", "left float-left");
			attr(div1, "class", "top h-32px text-sm font-thin px-4 py-4 md:py-2");
			attr(input, "type", "number");
			attr(input, "class", "font-thin text-base w-60pc md:w-75pc md:text-xl");
			attr(img, "class", "token-icon w-20px h-20px md:h-26px md:w-26px my-4px mx-2px");
			if (img.src !== (img_src_value = /*tokenLogo*/ ctx[10])) attr(img, "src", img_src_value);
			attr(img, "alt", /*tokenSymbol*/ ctx[9]);
			attr(span, "class", "py-2px px-4px");
			attr(div2, "class", "asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex\n          align-middle justify-center items-center pointer mt-0 md:mt-14px");
			attr(div3, "class", "bottom  px-4 py-4 md:px-4 pb-4");
			attr(div4, "class", "input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div1);
			append(div1, div0);
			append(div0, t0);
			append(div1, t1);
			if (if_block) if_block.m(div1, null);
			append(div4, t2);
			append(div4, div3);
			append(div3, input);
			set_input_value(input, /*amount*/ ctx[2]);
			append(div3, t3);
			append(div3, div2);
			append(div2, img);
			append(div2, t4);
			append(div2, span);
			append(span, t5);
			append(div3, t6);
			mount_component(tokenselectmodal, div3, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "keyup", debounce(/*fetchAmounts*/ ctx[17], 250)),
					listen(input, "input", /*input_input_handler*/ ctx[29]),
					listen(div2, "click", /*click_handler_7*/ ctx[30])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*$_*/ 16384) && t0_value !== (t0_value = /*$_*/ ctx[14]("general.amount") + "")) set_data(t0, t0_value);

			if (/*approach*/ ctx[3] === "withdraw") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_9(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*amount*/ 4 && to_number(input.value) !== /*amount*/ ctx[2]) {
				set_input_value(input, /*amount*/ ctx[2]);
			}

			if (!current || dirty[0] & /*tokenLogo*/ 1024 && img.src !== (img_src_value = /*tokenLogo*/ ctx[10])) {
				attr(img, "src", img_src_value);
			}

			if (!current || dirty[0] & /*tokenSymbol*/ 512) {
				attr(img, "alt", /*tokenSymbol*/ ctx[9]);
			}

			if (!current || dirty[0] & /*tokenSymbol*/ 512) set_data(t5, /*tokenSymbol*/ ctx[9]);
			const tokenselectmodal_changes = {};
			if (dirty[0] & /*pieTokens*/ 256) tokenselectmodal_changes.tokens = /*pieTokens*/ ctx[8];
			if (dirty[0] & /*tokenSelectModalOpen*/ 2) tokenselectmodal_changes.open = /*tokenSelectModalOpen*/ ctx[1];
			tokenselectmodal.$set(tokenselectmodal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tokenselectmodal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tokenselectmodal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			if (if_block) if_block.d();
			destroy_component(tokenselectmodal);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (453:8) {#if approach === "withdraw"}
function create_if_block_9(ctx) {
	let div4;
	let div0;
	let t1;
	let div1;
	let t3;
	let div2;
	let t5;
	let div3;
	let mounted;
	let dispose;

	return {
		c() {
			div4 = element("div");
			div0 = element("div");
			div0.textContent = "25%";
			t1 = space();
			div1 = element("div");
			div1.textContent = "50%";
			t3 = space();
			div2 = element("div");
			div2.textContent = "75%";
			t5 = space();
			div3 = element("div");
			div3.textContent = "100%";
			attr(div0, "class", "percentage-btn inline-block rounded-20px h-20px bg-black w-50px cursor-pointer");
			attr(div1, "class", "percentage-btn inline-block rounded-20px h-20px bg-black w-50px cursor-pointer");
			attr(div2, "class", "percentage-btn inline-block rounded-20px h-20px bg-black w-50px cursor-pointer");
			attr(div3, "class", "percentage-btn inline-block rounded-20px h-20px bg-black w-50px cursor-pointer");
			attr(div4, "class", "right text-white font-bold text-xs py-1px text-center align-right float-right rounded");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div0);
			append(div4, t1);
			append(div4, div1);
			append(div4, t3);
			append(div4, div2);
			append(div4, t5);
			append(div4, div3);

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*click_handler_3*/ ctx[25]),
					listen(div1, "click", /*click_handler_4*/ ctx[26]),
					listen(div2, "click", /*click_handler_5*/ ctx[27]),
					listen(div3, "click", /*click_handler_6*/ ctx[28])
				];

				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div4);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (496:2) {#if type === 'single'}
function create_if_block_7(ctx) {
	let div5;
	let div2;
	let div0;
	let t0_value = /*$_*/ ctx[14]("general.amount") + "";
	let t0;
	let t1;
	let div1;
	let t2;
	let t3_value = /*$_*/ ctx[14]("pool.slippage") + "";
	let t3;
	let t4;
	let div4;
	let input;
	let t5;
	let div3;
	let img;
	let img_src_value;
	let t6;
	let span;
	let t7;
	let t8;
	let tokenselectmodal;
	let current;
	let mounted;
	let dispose;

	tokenselectmodal = new TokenSelectModal({
			props: {
				tokens: /*pieTokens*/ ctx[8],
				open: /*tokenSelectModalOpen*/ ctx[1],
				callback: /*tokenSelectCallback*/ ctx[15]
			}
		});

	return {
		c() {
			div5 = element("div");
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			t2 = text("⚠️ ");
			t3 = text(t3_value);
			t4 = space();
			div4 = element("div");
			input = element("input");
			t5 = space();
			div3 = element("div");
			img = element("img");
			t6 = space();
			span = element("span");
			t7 = text(/*tokenSymbol*/ ctx[9]);
			t8 = space();
			create_component(tokenselectmodal.$$.fragment);
			attr(div0, "class", "left float-left");
			attr(div1, "class", "right font-bold text-xs py-1px text-center align-right float-right rounded");
			attr(div2, "class", "top h-32px text-sm font-thin px-4 py-4 md:py-2");
			attr(input, "type", "number");
			attr(input, "class", "font-thin text-base w-60pc md:w-75pc md:text-xl");
			attr(img, "class", "token-icon w-20px h-20px md:h-26px md:w-26px my-4px mx-2px");
			if (img.src !== (img_src_value = /*tokenLogo*/ ctx[10])) attr(img, "src", img_src_value);
			attr(img, "alt", /*tokenSymbol*/ ctx[9]);
			attr(span, "class", "py-2px px-4px");
			attr(div3, "class", "asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex\n          align-middle justify-center items-center pointer mt-0 md:mt-14px");
			attr(div4, "class", "bottom px-4 py-4 md:py-2");
			attr(div5, "class", "input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div2);
			append(div2, div0);
			append(div0, t0);
			append(div2, t1);
			append(div2, div1);
			append(div1, t2);
			append(div1, t3);
			append(div5, t4);
			append(div5, div4);
			append(div4, input);
			set_input_value(input, /*amount*/ ctx[2]);
			append(div4, t5);
			append(div4, div3);
			append(div3, img);
			append(div3, t6);
			append(div3, span);
			append(span, t7);
			append(div4, t8);
			mount_component(tokenselectmodal, div4, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "keyup", debounce(/*fetchQuote*/ ctx[16], 250)),
					listen(input, "input", /*input_input_handler_1*/ ctx[31]),
					listen(div3, "click", /*click_handler_8*/ ctx[32])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*$_*/ 16384) && t0_value !== (t0_value = /*$_*/ ctx[14]("general.amount") + "")) set_data(t0, t0_value);
			if ((!current || dirty[0] & /*$_*/ 16384) && t3_value !== (t3_value = /*$_*/ ctx[14]("pool.slippage") + "")) set_data(t3, t3_value);

			if (dirty[0] & /*amount*/ 4 && to_number(input.value) !== /*amount*/ ctx[2]) {
				set_input_value(input, /*amount*/ ctx[2]);
			}

			if (!current || dirty[0] & /*tokenLogo*/ 1024 && img.src !== (img_src_value = /*tokenLogo*/ ctx[10])) {
				attr(img, "src", img_src_value);
			}

			if (!current || dirty[0] & /*tokenSymbol*/ 512) {
				attr(img, "alt", /*tokenSymbol*/ ctx[9]);
			}

			if (!current || dirty[0] & /*tokenSymbol*/ 512) set_data(t7, /*tokenSymbol*/ ctx[9]);
			const tokenselectmodal_changes = {};
			if (dirty[0] & /*pieTokens*/ 256) tokenselectmodal_changes.tokens = /*pieTokens*/ ctx[8];
			if (dirty[0] & /*tokenSelectModalOpen*/ 2) tokenselectmodal_changes.open = /*tokenSelectModalOpen*/ ctx[1];
			tokenselectmodal.$set(tokenselectmodal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tokenselectmodal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tokenselectmodal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			destroy_component(tokenselectmodal);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (522:2) {#if isLoading === true}
function create_if_block_6(ctx) {
	let div11;

	return {
		c() {
			div11 = element("div");
			div11.innerHTML = `<div class="loadingio-spinner-wedges-meab1ddaeuq"><div class="ldio-qudhur211ps"><div><div><div></div></div><div><div></div></div><div><div></div></div><div><div></div></div></div></div></div>`;
			attr(div11, "class", "h-12px mx-50pc my-16px");
		},
		m(target, anchor) {
			insert(target, div11, anchor);
		},
		d(detaching) {
			if (detaching) detach(div11);
		}
	};
}

// (529:2) {#if type === 'multi' && isLoading != true}
function create_if_block_5(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			if (img.src !== (img_src_value = images.icons.downArrow)) attr(img, "src", img_src_value);
			attr(img, "class", "h-12px mx-50pc my-16px");
			attr(img, "alt", "down arrow icon");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (533:2) {#if type === 'single'}
function create_if_block_4(ctx) {
	let div;
	let t_value = /*$_*/ ctx[14]("pool.using.eth") + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "my-16px mx-20px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t_value !== (t_value = /*$_*/ ctx[14]("pool.using.eth") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (540:2) {#if type === 'single'}
function create_if_block_3(ctx) {
	let div4;
	let div1;
	let div0;
	let t0_value = /*$_*/ ctx[14]("general.amount") + "";
	let t0;
	let t1;
	let div3;
	let input;
	let input_value_value;
	let t2;
	let div2;
	let img;
	let img_src_value;
	let t3;
	let span;

	return {
		c() {
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div3 = element("div");
			input = element("input");
			t2 = space();
			div2 = element("div");
			img = element("img");
			t3 = space();
			span = element("span");
			span.textContent = "ETH";
			attr(div0, "class", "left float-left");
			attr(div1, "class", "top h-32px text-sm font-thin px-4 py-4 md:py-2");
			attr(input, "type", "text");
			input.disabled = true;
			input.value = input_value_value = /*ethNeededSingleEntry*/ ctx[5].label;
			attr(input, "class", "font-thin text-base w-60pc md:w-75pc md:text-xl");
			attr(img, "class", "token-icon w-26px h-26px my-4px mx-2px");
			if (img.src !== (img_src_value = getTokenImage("eth"))) attr(img, "src", img_src_value);
			attr(img, "alt", "ETH");
			attr(span, "class", "py-2px px-4px");
			attr(div2, "class", "asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex\n        align-middle justify-center items-center pointer mt-0 md:mt-14px");
			attr(div3, "class", "bottom px-4 py-4 md:py-2");
			attr(div4, "class", "input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div1);
			append(div1, div0);
			append(div0, t0);
			append(div4, t1);
			append(div4, div3);
			append(div3, input);
			append(div3, t2);
			append(div3, div2);
			append(div2, img);
			append(div2, t3);
			append(div2, span);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t0_value !== (t0_value = /*$_*/ ctx[14]("general.amount") + "")) set_data(t0, t0_value);

			if (dirty[0] & /*ethNeededSingleEntry*/ 32 && input_value_value !== (input_value_value = /*ethNeededSingleEntry*/ ctx[5].label) && input.value !== input_value_value) {
				input.value = input_value_value;
			}
		},
		d(detaching) {
			if (detaching) detach(div4);
		}
	};
}

// (557:2) {#if type === 'multi'}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let each_value = /*pooledTokens*/ ctx[12];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$eth, amountsRequired, pooledTokens, approach*/ 12360) {
				each_value = /*pooledTokens*/ ctx[12];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (587:8) {:else}
function create_else_block_1(ctx) {
	let div;

	let t_value = (/*amountsRequired*/ ctx[6][/*pooledToken*/ ctx[47].address.toLowerCase()]
	? /*amountsRequired*/ ctx[6][/*pooledToken*/ ctx[47].address.toLowerCase()].label
	: "-") + "";

	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "amount tex-sm px-20px py-12px m-auto");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*amountsRequired, pooledTokens*/ 4160 && t_value !== (t_value = (/*amountsRequired*/ ctx[6][/*pooledToken*/ ctx[47].address.toLowerCase()]
			? /*amountsRequired*/ ctx[6][/*pooledToken*/ ctx[47].address.toLowerCase()].label
			: "-") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (576:8) {#if approach === "add"}
function create_if_block_2(ctx) {
	let div;

	let t_value = (/*amountsRequired*/ ctx[6][/*pooledToken*/ ctx[47].address.toLowerCase()]
	? /*amountsRequired*/ ctx[6][/*pooledToken*/ ctx[47].address.toLowerCase()].label
	: "-") + "";

	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "amount tex-sm px-20px py-12px w-150px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*amountsRequired, pooledTokens*/ 4160 && t_value !== (t_value = (/*amountsRequired*/ ctx[6][/*pooledToken*/ ctx[47].address.toLowerCase()]
			? /*amountsRequired*/ ctx[6][/*pooledToken*/ ctx[47].address.toLowerCase()].label
			: "-") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (558:4) {#each pooledTokens as pooledToken}
function create_each_block(ctx) {
	let div3;
	let div0;

	let t0_value = amountFormatter({
		amount: /*pooledToken*/ ctx[47].originalWeight,
		approximatePrefix: "",
		displayDecimals: 2,
		rounding: 4
	}) + "";

	let t0;
	let t1;
	let div0_style_value;
	let t2;
	let img;
	let img_src_value;
	let img_alt_value;
	let t3;
	let div1;
	let t4_value = /*pooledToken*/ ctx[47].symbol + "";
	let t4;
	let t5;
	let t6;
	let div2;
	let t7_value = /*$eth*/ ctx[13].address + "";
	let t7;
	let t8;

	function select_block_type_3(ctx, dirty) {
		if (/*approach*/ ctx[3] === "add") return create_if_block_2;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_3(ctx, [-1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = text("%");
			t2 = space();
			img = element("img");
			t3 = space();
			div1 = element("div");
			t4 = text(t4_value);
			t5 = space();
			if_block.c();
			t6 = space();
			div2 = element("div");
			t7 = text(t7_value);
			t8 = space();
			attr(div0, "class", "min-w-22pc p-12px text-sm md:text-lg");
			attr(div0, "style", div0_style_value = `color: ${/*pooledToken*/ ctx[47].color}`);
			attr(img, "class", "token-icon my-8px w-26px h-26px");
			if (img.src !== (img_src_value = getTokenImage(/*pooledToken*/ ctx[47].address))) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*pooledToken*/ ctx[47].symbol);
			attr(div1, "class", "token-symbol min-w-15pc md:min-w-10pc px-6px py-12px text-sm font-thin border-r-2 border-r-solid border-grey-243 align-middle md:leading-8");
			attr(div2, "class", "hidden");
			attr(div3, "class", "token-summary overflow-x-scroll bg-white rounded-8px mx-0 md:mx-4 my-4px flex flex-start items-center");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);
			append(div0, t0);
			append(div0, t1);
			append(div3, t2);
			append(div3, img);
			append(div3, t3);
			append(div3, div1);
			append(div1, t4);
			append(div3, t5);
			if_block.m(div3, null);
			append(div3, t6);
			append(div3, div2);
			append(div2, t7);
			append(div3, t8);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*pooledTokens*/ 4096 && t0_value !== (t0_value = amountFormatter({
				amount: /*pooledToken*/ ctx[47].originalWeight,
				approximatePrefix: "",
				displayDecimals: 2,
				rounding: 4
			}) + "")) set_data(t0, t0_value);

			if (dirty[0] & /*pooledTokens*/ 4096 && div0_style_value !== (div0_style_value = `color: ${/*pooledToken*/ ctx[47].color}`)) {
				attr(div0, "style", div0_style_value);
			}

			if (dirty[0] & /*pooledTokens*/ 4096 && img.src !== (img_src_value = getTokenImage(/*pooledToken*/ ctx[47].address))) {
				attr(img, "src", img_src_value);
			}

			if (dirty[0] & /*pooledTokens*/ 4096 && img_alt_value !== (img_alt_value = /*pooledToken*/ ctx[47].symbol)) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty[0] & /*pooledTokens*/ 4096 && t4_value !== (t4_value = /*pooledToken*/ ctx[47].symbol + "")) set_data(t4, t4_value);

			if (current_block_type === (current_block_type = select_block_type_3(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div3, t6);
				}
			}

			if (dirty[0] & /*$eth*/ 8192 && t7_value !== (t7_value = /*$eth*/ ctx[13].address + "")) set_data(t7, t7_value);
		},
		d(detaching) {
			if (detaching) detach(div3);
			if_block.d();
		}
	};
}

// (602:6) {:else}
function create_else_block(ctx) {
	let t_value = /*$_*/ ctx[14]("general.withdraw") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t_value !== (t_value = /*$_*/ ctx[14]("general.withdraw") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (600:6) {#if approach === 'add'}
function create_if_block(ctx) {
	let t0_value = /*$_*/ ctx[14]("general.add") + "";
	let t0;
	let t1_value = /*$_*/ ctx[14]("general.liquidity") + "";
	let t1;

	return {
		c() {
			t0 = text(t0_value);
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_*/ 16384 && t0_value !== (t0_value = /*$_*/ ctx[14]("general.add") + "")) set_data(t0, t0_value);
			if (dirty[0] & /*$_*/ 16384 && t1_value !== (t1_value = /*$_*/ ctx[14]("general.liquidity") + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

function create_fragment(ctx) {
	let div4;
	let h1;
	let t0;
	let div3;
	let div0;
	let t1_value = /*$_*/ ctx[14]("general.single") + "";
	let t1;
	let t2_value = /*$_*/ ctx[14]("general.asset") + "";
	let t2;
	let t3;
	let div1;
	let input;
	let input_checked_value;
	let t4;
	let span;
	let t5;
	let div2;
	let t6_value = /*$_*/ ctx[14]("general.multi") + "";
	let t6;
	let t7_value = /*$_*/ ctx[14]("general.asset") + "";
	let t7;
	let t8;
	let p;
	let t9;
	let t10;
	let t11;
	let t12;
	let t13;
	let t14;
	let t15;
	let t16;
	let t17;
	let t18;
	let center;
	let button;
	let button_disabled_value;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*approach*/ ctx[3] === "add") return create_if_block_15;
		return create_else_block_4;
	}

	let current_block_type = select_block_type(ctx, [-1]);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*type*/ ctx[11] === "single" && create_if_block_14(ctx);
	let if_block2 = /*type*/ ctx[11] === "multi" && create_if_block_11(ctx);
	let if_block3 = /*type*/ ctx[11] === "multi" && create_if_block_10(ctx);
	let if_block4 = /*type*/ ctx[11] === "multi" && create_if_block_8(ctx);
	let if_block5 = /*type*/ ctx[11] === "single" && create_if_block_7(ctx);
	let if_block6 = /*isLoading*/ ctx[7] === true && create_if_block_6(ctx);
	let if_block7 = /*type*/ ctx[11] === "multi" && /*isLoading*/ ctx[7] != true && create_if_block_5(ctx);
	let if_block8 = /*type*/ ctx[11] === "single" && create_if_block_4(ctx);
	let if_block9 = /*type*/ ctx[11] === "single" && create_if_block_3(ctx);
	let if_block10 = /*type*/ ctx[11] === "multi" && create_if_block_1(ctx);

	function select_block_type_4(ctx, dirty) {
		if (/*approach*/ ctx[3] === "add") return create_if_block;
		return create_else_block;
	}

	let current_block_type_1 = select_block_type_4(ctx, [-1]);
	let if_block11 = current_block_type_1(ctx);

	return {
		c() {
			div4 = element("div");
			h1 = element("h1");
			if_block0.c();
			t0 = space();
			div3 = element("div");
			div0 = element("div");
			t1 = text(t1_value);
			t2 = text(t2_value);
			t3 = space();
			div1 = element("div");
			input = element("input");
			t4 = space();
			span = element("span");
			t5 = space();
			div2 = element("div");
			t6 = text(t6_value);
			t7 = text(t7_value);
			t8 = space();
			p = element("p");
			if (if_block1) if_block1.c();
			t9 = space();
			if (if_block2) if_block2.c();
			t10 = space();
			if (if_block3) if_block3.c();
			t11 = space();
			if (if_block4) if_block4.c();
			t12 = space();
			if (if_block5) if_block5.c();
			t13 = space();
			if (if_block6) if_block6.c();
			t14 = space();
			if (if_block7) if_block7.c();
			t15 = space();
			if (if_block8) if_block8.c();
			t16 = space();
			if (if_block9) if_block9.c();
			t17 = space();
			if (if_block10) if_block10.c();
			t18 = space();
			center = element("center");
			button = element("button");
			if_block11.c();
			attr(h1, "class", "text-center text-xl");
			attr(div0, "class", "flex-auto text-right");
			attr(input, "type", "checkbox");
			attr(input, "class", "toggle-input");
			input.checked = input_checked_value = /*type*/ ctx[11] === "multi";
			attr(span, "class", "toggle active border-grey");
			attr(div1, "class", "switch mx-4");
			attr(div2, "class", "flex-auto text-left");
			attr(div3, "class", "row flex font-thin");
			attr(p, "class", "text-center font-thin my-4 mx-2");
			button.disabled = button_disabled_value = !/*areTokensEnoughBool*/ ctx[4] && /*type*/ ctx[11] === "multi";
			attr(button, "class", "btn m-0 mt-4 rounded-8px px-56px py-15px");
			attr(div4, "class", "liquidity-container bg-grey-243 rounded-4px p-4 md:p-6 w-full");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, h1);
			if_block0.m(h1, null);
			append(div4, t0);
			append(div4, div3);
			append(div3, div0);
			append(div0, t1);
			append(div0, t2);
			append(div3, t3);
			append(div3, div1);
			append(div1, input);
			append(div1, t4);
			append(div1, span);
			append(div3, t5);
			append(div3, div2);
			append(div2, t6);
			append(div2, t7);
			append(div4, t8);
			append(div4, p);
			if (if_block1) if_block1.m(p, null);
			append(p, t9);
			if (if_block2) if_block2.m(p, null);
			append(div4, t10);
			if (if_block3) if_block3.m(div4, null);
			append(div4, t11);
			if (if_block4) if_block4.m(div4, null);
			append(div4, t12);
			if (if_block5) if_block5.m(div4, null);
			append(div4, t13);
			if (if_block6) if_block6.m(div4, null);
			append(div4, t14);
			if (if_block7) if_block7.m(div4, null);
			append(div4, t15);
			if (if_block8) if_block8.m(div4, null);
			append(div4, t16);
			if (if_block9) if_block9.m(div4, null);
			append(div4, t17);
			if (if_block10) if_block10.m(div4, null);
			append(div4, t18);
			append(div4, center);
			append(center, button);
			if_block11.m(button, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "click", /*click_handler*/ ctx[22]),
					listen(button, "click", /*click_handler_9*/ ctx[33])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(h1, null);
				}
			}

			if ((!current || dirty[0] & /*$_*/ 16384) && t1_value !== (t1_value = /*$_*/ ctx[14]("general.single") + "")) set_data(t1, t1_value);
			if ((!current || dirty[0] & /*$_*/ 16384) && t2_value !== (t2_value = /*$_*/ ctx[14]("general.asset") + "")) set_data(t2, t2_value);

			if (!current || dirty[0] & /*type*/ 2048 && input_checked_value !== (input_checked_value = /*type*/ ctx[11] === "multi")) {
				input.checked = input_checked_value;
			}

			if ((!current || dirty[0] & /*$_*/ 16384) && t6_value !== (t6_value = /*$_*/ ctx[14]("general.multi") + "")) set_data(t6, t6_value);
			if ((!current || dirty[0] & /*$_*/ 16384) && t7_value !== (t7_value = /*$_*/ ctx[14]("general.asset") + "")) set_data(t7, t7_value);

			if (/*type*/ ctx[11] === "single") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_14(ctx);
					if_block1.c();
					if_block1.m(p, t9);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*type*/ ctx[11] === "multi") {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_11(ctx);
					if_block2.c();
					if_block2.m(p, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*type*/ ctx[11] === "multi") {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_10(ctx);
					if_block3.c();
					if_block3.m(div4, t11);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*type*/ ctx[11] === "multi") {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*type*/ 2048) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_8(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div4, t12);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*type*/ ctx[11] === "single") {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*type*/ 2048) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_7(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(div4, t13);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*isLoading*/ ctx[7] === true) {
				if (if_block6) {
					
				} else {
					if_block6 = create_if_block_6(ctx);
					if_block6.c();
					if_block6.m(div4, t14);
				}
			} else if (if_block6) {
				if_block6.d(1);
				if_block6 = null;
			}

			if (/*type*/ ctx[11] === "multi" && /*isLoading*/ ctx[7] != true) {
				if (if_block7) {
					if_block7.p(ctx, dirty);
				} else {
					if_block7 = create_if_block_5(ctx);
					if_block7.c();
					if_block7.m(div4, t15);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (/*type*/ ctx[11] === "single") {
				if (if_block8) {
					if_block8.p(ctx, dirty);
				} else {
					if_block8 = create_if_block_4(ctx);
					if_block8.c();
					if_block8.m(div4, t16);
				}
			} else if (if_block8) {
				if_block8.d(1);
				if_block8 = null;
			}

			if (/*type*/ ctx[11] === "single") {
				if (if_block9) {
					if_block9.p(ctx, dirty);
				} else {
					if_block9 = create_if_block_3(ctx);
					if_block9.c();
					if_block9.m(div4, t17);
				}
			} else if (if_block9) {
				if_block9.d(1);
				if_block9 = null;
			}

			if (/*type*/ ctx[11] === "multi") {
				if (if_block10) {
					if_block10.p(ctx, dirty);
				} else {
					if_block10 = create_if_block_1(ctx);
					if_block10.c();
					if_block10.m(div4, t18);
				}
			} else if (if_block10) {
				if_block10.d(1);
				if_block10 = null;
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_4(ctx, dirty)) && if_block11) {
				if_block11.p(ctx, dirty);
			} else {
				if_block11.d(1);
				if_block11 = current_block_type_1(ctx);

				if (if_block11) {
					if_block11.c();
					if_block11.m(button, null);
				}
			}

			if (!current || dirty[0] & /*areTokensEnoughBool, type*/ 2064 && button_disabled_value !== (button_disabled_value = !/*areTokensEnoughBool*/ ctx[4] && /*type*/ ctx[11] === "multi")) {
				button.disabled = button_disabled_value;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block4);
			transition_in(if_block5);
			current = true;
		},
		o(local) {
			transition_out(if_block4);
			transition_out(if_block5);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (if_block7) if_block7.d();
			if (if_block8) if_block8.d();
			if (if_block9) if_block9.d();
			if (if_block10) if_block10.d();
			if_block11.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $balances;
	let $pools;
	let $allowances;
	let $eth;
	let $_;
	component_subscribe($$self, balances, $$value => $$invalidate(36, $balances = $$value));
	component_subscribe($$self, pools, $$value => $$invalidate(37, $pools = $$value));
	component_subscribe($$self, allowances, $$value => $$invalidate(38, $allowances = $$value));
	component_subscribe($$self, eth, $$value => $$invalidate(13, $eth = $$value));
	component_subscribe($$self, _, $$value => $$invalidate(14, $_ = $$value));
	window.B = BigNumber;
	let { token } = $$props;
	let { poolAction } = $$props;
	let { method } = $$props; // NOTE: This really should be named poolAddress. Token is too generic.;
	let tokenSelectModalOpen = false;

	const tokenSelectCallback = token => {
		$$invalidate(1, tokenSelectModalOpen = false);

		if (token) {
			window.location.hash = `#/pools/${token.address}`;
			fetchQuote(null, token.address);
		}
	};

	let amount = "1.00000000";
	let approach = poolAction;
	let areTokensEnoughBool = true;
	let ethKey;
	let ethBalance = 0;
	let ethNeededSingleEntry = { val: 0, label: "-" };
	let amountsRequired = {};
	let isLoading;

	const fetchQuote = async (event, pieAddress = null) => {
		$$invalidate(5, ethNeededSingleEntry.label = "-", ethNeededSingleEntry);

		try {
			$$invalidate(7, isLoading = true);
			const pieToMint = pieAddress || token;
			$$invalidate(5, ethNeededSingleEntry = await fetchCalcToPie(pieToMint, amount));
			$$invalidate(7, isLoading = false);
		} catch(e) {
			console.error(e);
		}
	};

	const fetchAmounts = async (event, pieAddress = null) => {
		try {
			$$invalidate(7, isLoading = true);
			const pieToMint = pieAddress || token;
			$$invalidate(6, amountsRequired = await fetchCalcTokensForAmounts(pieToMint, amount));
			$$invalidate(7, isLoading = false);
			areTokensEnough();
		} catch(e) {
			console.error(e);
		}
	};

	onMount(async () => {
		fetchQuote();
		fetchAmounts();
	});

	const action = async (evt, pooledToken) => {
		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const { address } = pooledToken;

		if (pooledToken.actionBtnLabel === "Unlock") {
			await approveMax(address, token);
		} else if (pooledToken.actionBtnLabel === "ready") {
			evt.preventDefault();
		}
	};

	const calcArb = () => {
		const reserveA = BigNumber(3490);
		const reserveB = BigNumber(890);
		const truePriceTokenA = BigNumber(1);
		const truePriceTokenB = BigNumber(2.4);
		const aToB = BigNumber(BigNumber(amount).multipliedBy(truePriceTokenB).dividedBy(reserveB)).isGreaterThan(truePriceTokenA);

		// aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;
		const invariant = reserveA.multipliedBy(reserveB);

		const leftSide = invariant.multipliedBy(aToB ? truePriceTokenA : truePriceTokenB).multipliedBy(BigNumber(1000)).dividedBy(aToB ? truePriceTokenB : truePriceTokenA).multipliedBy(997).sqrt();

		// uint256 leftSide = Babylonian.sqrt(
		//     invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /
		//     uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)
		// );
		const rightSide = (aToB
		? reserveA.multipliedBy(BigNumber(1000))
		: reserveB.multipliedBy(BigNumber(1000))).dividedBy(BigNumber(997));

		// uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;
		// // compute the amount that must be sent to move the price to the profit-maximizing price
		const amountIn = leftSide.minus(rightSide);

		console.log("amountIn", amountIn.toString());
	};

	const mintFromRecipe = async () => {
		const requestedAmount = BigNumber(amount);
		const max = BigNumber(ethBalance).multipliedBy(10 ** 18).toFixed(0);
		await fetchQuote();

		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const percentagePlus = BigNumber(ethNeededSingleEntry.val.toString()).multipliedBy(BigNumber(1.05)).toFixed(0);

		if (BigNumber(percentagePlus).isGreaterThan(BigNumber(max))) {
			const maxFormatted = amountFormatter({ amount: max, displayDecimals: 8 });

			//TODO i18n
			const message = `Not enough ETH`;

			displayNotification({
				message,
				type: "error",
				autoDismiss: 30000
			});

			return;
		}

		const recipe = await contract({
			address: "0xca9af520706a57cecde6f596852eabb5a0e6bb0e",
			abi: recipeAbi
		});

		const amountWei = requestedAmount.multipliedBy(10 ** 18).toFixed(0);
		let overrides = { value: percentagePlus };

		console.log({
			pie: token,
			amountWei,
			value: ethNeededSingleEntry.val
		});

		const { emitter } = displayNotification(await recipe.toPie(token, amountWei, overrides));

		emitter.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} ${tokenSymbol} successfully minted`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const areTokensEnough = () => {
		let errors = [];

		Object.keys(amountsRequired).forEach(token => {
			let key = balanceKey(token, $eth.address);
			let max = $balances[key];

			if (BigNumber(amountsRequired[token].label).isGreaterThan(BigNumber(max.toString()))) {
				errors.push(token);
			}
		});

		if (errors.length > 0) {
			console.log("Missing tokens", errors);
			$$invalidate(4, areTokensEnoughBool = false);

			displayNotification({
				message: "Looks like you are missing some tokens!",
				type: "error",
				autoDismiss: 30000
			});

			return false;
		}

		$$invalidate(4, areTokensEnoughBool = true);
		return true;
	};

	const askApproval = async (address, spender) => {
		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		let erc20Contract = new ethers.Contract(address, erc20, $eth.signer);
		console.log("Im being calle");
		const { hash } = await erc20Contract["approve(address,uint256)"](spender, ethers.constants.MaxUint256);
		const { emitter } = displayNotification({ hash });
		const symbol = await erc20Contract.symbol();

		await new Promise(resolve => emitter.on("txConfirmed", ({ blockNumber }) => {
				currentBlockNumber = blockNumber;
				resolve();

				return {
					message: `${symbol} unlocked`,
					type: "success"
				};
			}));
	};

	const mint = async () => {
		try {
			const requestedAmount = BigNumber(amount);

			if (!$eth.address || !$eth.signer) {
				displayNotification({
					message: $_("piedao.please.connect.wallet"),
					type: "hint"
				});

				connectWeb3();
				return;
			}

			if (!areTokensEnough()) {
				return;
			}

			for (let i = 0; i < lockedPoolTokens.length; i += 1) {
				askApproval(lockedPoolTokens[i].address, token);
			}

			const tokenContract = await contract({ abi: pieSmartPool, address: token });
			const decimals = await tokenContract.decimals();
			const arg = requestedAmount.multipliedBy(10 ** decimals).toFixed(0);
			const { emitter } = displayNotification(await tokenContract.joinPool(arg));

			emitter.on("txConfirmed", ({ hash }) => {
				const { dismiss } = displayNotification({
					message: "Confirming...",
					type: "pending"
				});

				const subscription = subject("blockNumber").subscribe({
					next: () => {
						displayNotification({
							autoDismiss: 15000,
							message: `${requestedAmount.toFixed()} ${tokenSymbol} successfully minted`,
							type: "success"
						});

						dismiss();
						subscription.unsubscribe();
					}
				});

				return {
					autoDismiss: 1,
					message: "Mined",
					type: "success"
				};
			});
		} catch(e) {
			displayNotification({
				message: e.message,
				type: "error",
				autoDismiss: 30000
			});
		}
	};

	const primaryAction = () => {
		if (type === "single") {
			mintFromRecipe();
			return;
		}

		if (approach === "add") {
			mint();
		} else {
			withdraw();
		}
	};

	const setValuePercentage = percent => {
		let max = maxAmount(token, pooledTokens);

		if (approach === "withdraw") {
			const key = balanceKey(token, $eth.address);
			max = $balances[key];
		}

		const adjusted = max.multipliedBy(BigNumber(percent).dividedBy(100));
		$$invalidate(2, amount = adjusted.toFixed(8, BigNumber.ROUND_DOWN));
		fetchAmounts();
	};

	const withdraw = async () => {
		const requestedAmount = BigNumber(amount);
		const key = balanceKey(token, $eth.address);
		const max = $balances[key];

		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		if (requestedAmount.isGreaterThan(max)) {
			const maxFormatted = amountFormatter({ amount: max, displayDecimals: 8 });
			const message = `${$_("piedao.max.withdraw.notice")} ${maxFormatted} ${tokenSymbol}.`;

			displayNotification({
				message,
				type: "error",
				autoDismiss: 30000
			});

			return;
		}

		const tokenContract = await contract({ abi: pieSmartPool, address: token });
		const decimals = await tokenContract.decimals();
		const arg = requestedAmount.multipliedBy(10 ** decimals).toFixed(0);
		const { emitter } = displayNotification(await tokenContract.exitPool(arg));

		emitter.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: $_("piedao.confirming"),
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} ${tokenSymbol} ` + `${$_("general.successfully").toLowerCase()} ${$_("general.withdrawn").toLowerCase()}`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: $_("general.mined"),
				type: "success"
			};
		});
	};

	const click_handler = () => {
		if (!poolsConfig[token].useRecipe) {
			alert($_("piedao.single.asset.coming.soon"));
			return;
		}

		if (type === "single") {
			$$invalidate(11, type = "multi");
		} else {
			$$invalidate(11, type = "single");
			$$invalidate(3, approach = "add");
		}
	};

	const click_handler_1 = () => $$invalidate(3, approach = "add");
	const click_handler_2 = () => $$invalidate(3, approach = "withdraw");
	const click_handler_3 = () => setValuePercentage(25);
	const click_handler_4 = () => setValuePercentage(50);
	const click_handler_5 = () => setValuePercentage(75);
	const click_handler_6 = () => setValuePercentage(100);

	function input_input_handler() {
		amount = to_number(this.value);
		$$invalidate(2, amount);
	}

	const click_handler_7 = () => $$invalidate(1, tokenSelectModalOpen = true);

	function input_input_handler_1() {
		amount = to_number(this.value);
		$$invalidate(2, amount);
	}

	const click_handler_8 = () => $$invalidate(1, tokenSelectModalOpen = true);
	const click_handler_9 = () => primaryAction();

	$$self.$$set = $$props => {
		if ("token" in $$props) $$invalidate(0, token = $$props.token);
		if ("poolAction" in $$props) $$invalidate(20, poolAction = $$props.poolAction);
		if ("method" in $$props) $$invalidate(21, method = $$props.method);
	};

	let pieTokens;
	let tokenSymbol;
	let tokenLogo;
	let type;
	let pooledTokens;
	let lockedPoolTokens;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*$balances*/ 32) {
			$: $$invalidate(8, pieTokens = fetchPieTokens($balances));
		}

		if ($$self.$$.dirty[0] & /*token*/ 1) {
			$: $$invalidate(9, tokenSymbol = (poolsConfig[token] || {}).symbol);
		}

		if ($$self.$$.dirty[0] & /*token*/ 1) {
			$: $$invalidate(10, tokenLogo = images.logos[token]);
		}

		if ($$self.$$.dirty[0] & /*token, method*/ 2097153) {
			$: $$invalidate(11, type = poolsConfig[token].useRecipe === true ? method : "multi");
		}

		if ($$self.$$.dirty[0] & /*token, amount*/ 5 | $$self.$$.dirty[1] & /*$pools, $allowances, $balances*/ 224) {
			$: $$invalidate(12, pooledTokens = fetchPooledTokens(token, amount, $pools[token], $allowances, $balances));
		}

		if ($$self.$$.dirty[0] & /*pooledTokens*/ 4096) {
			$: lockedPoolTokens = pooledTokens.filter(({ actionBtnLabel }) => actionBtnLabel === "Unlock");
		}

		if ($$self.$$.dirty[0] & /*$eth*/ 8192) {
			$: if ($eth.address) {
				fetchEthBalance($eth.address);
				$$invalidate(34, ethKey = balanceKey(ethers.constants.AddressZero, $eth.address));
			}
		}

		if ($$self.$$.dirty[1] & /*$balances, ethKey*/ 40) {
			$: ethBalance = BigNumber($balances[ethKey]).toString();
		}
	};

	return [
		token,
		tokenSelectModalOpen,
		amount,
		approach,
		areTokensEnoughBool,
		ethNeededSingleEntry,
		amountsRequired,
		isLoading,
		pieTokens,
		tokenSymbol,
		tokenLogo,
		type,
		pooledTokens,
		$eth,
		$_,
		tokenSelectCallback,
		fetchQuote,
		fetchAmounts,
		primaryAction,
		setValuePercentage,
		poolAction,
		method,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6,
		input_input_handler,
		click_handler_7,
		input_input_handler_1,
		click_handler_8,
		click_handler_9
	];
}

class Liquidity extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { token: 0, poolAction: 20, method: 21 }, [-1, -1]);
	}
}

export default Liquidity;