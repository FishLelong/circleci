/* src/components/Migration.svelte generated by Svelte v3.29.0 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	listen,
	mount_component,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	space,
	text,
	to_number,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import { onMount } from "../../web_modules/svelte.js";
import BigNumber from "../../web_modules/bignumberjs.js";
import debounce from "../../web_modules/lodash/debounce.js";
import { _ } from "../../web_modules/svelte-i18n.js";
import { ethers } from "../../web_modules/ethers.js";
import { pieSmartPool } from "../../web_modules/@pie-dao/abis.js";
import { get } from "../../web_modules/svelte/store.js";
import images from "../config/images.json.proxy.js";
import poolsConfig from "../config/pools.json.proxy.js";
import uniswapLpZapABI from "../config/uniswapLpZapABI.json.proxy.js";
import displayNotification from "../notifications.js";
import TokenSelectModal from "./TokenSelectModal.js";

import {
	allowances,
	approveMax,
	balanceKey,
	balances,
	connectWeb3,
	contract,
	eth,
	pools,
	bumpLifecycle,
	subject
} from "../stores/eth.js";

import {
	amountFormatter,
	fetchCalcTokensForAmounts,
	fetchPieTokens,
	fetchPooledTokens,
	maxAmount,
	getTokenImage,
	fetchEthBalance,
	fetchCalcToPie
} from "./helpers.js";

function create_else_block_1(ctx) {
	let t_value = /*$_*/ ctx[7]("general.withdraw") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 128 && t_value !== (t_value = /*$_*/ ctx[7]("general.withdraw") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (302:4) {#if approach === 'add'}
function create_if_block_3(ctx) {
	let t0_value = /*$_*/ ctx[7]("general.add") + "";
	let t0;
	let t1;
	let t2_value = /*$_*/ ctx[7]("general.liquidity") + "";
	let t2;

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 128 && t0_value !== (t0_value = /*$_*/ ctx[7]("general.add") + "")) set_data(t0, t0_value);
			if (dirty & /*$_*/ 128 && t2_value !== (t2_value = /*$_*/ ctx[7]("general.liquidity") + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

// (339:2) {#if isLoading === true}
function create_if_block_2(ctx) {
	let div11;

	return {
		c() {
			div11 = element("div");
			div11.innerHTML = `<div class="loadingio-spinner-wedges-meab1ddaeuq"><div class="ldio-qudhur211ps"><div><div><div></div></div><div><div></div></div><div><div></div></div><div><div></div></div></div></div></div>`;
			attr(div11, "class", "h-12px mx-50pc my-16px");
		},
		m(target, anchor) {
			insert(target, div11, anchor);
		},
		d(detaching) {
			if (detaching) detach(div11);
		}
	};
}

// (348:4) {#if tokenOut.type === 'UniswapV2'}
function create_if_block_1(ctx) {
	let t0;
	let t1_value = /*tokenOut*/ ctx[4].symbol + "";
	let t1;

	return {
		c() {
			t0 = text("Inside ü¶Ñ Uniswap V2 Pool: ");
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*tokenOut*/ 16 && t1_value !== (t1_value = /*tokenOut*/ ctx[4].symbol + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (377:6) {:else}
function create_else_block(ctx) {
	let t_value = /*$_*/ ctx[7]("general.withdraw") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 128 && t_value !== (t_value = /*$_*/ ctx[7]("general.withdraw") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (375:6) {#if approach === 'add'}
function create_if_block(ctx) {
	let t0_value = /*$_*/ ctx[7]("general.add") + "";
	let t0;
	let t1;
	let t2_value = /*$_*/ ctx[7]("general.liquidity") + "";
	let t2;

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 128 && t0_value !== (t0_value = /*$_*/ ctx[7]("general.add") + "")) set_data(t0, t0_value);
			if (dirty & /*$_*/ 128 && t2_value !== (t2_value = /*$_*/ ctx[7]("general.liquidity") + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

function create_fragment(ctx) {
	let div13;
	let h1;
	let t0;
	let p;
	let div0;
	let t2;
	let div6;
	let div3;
	let div1;
	let t3_value = /*$_*/ ctx[7]("general.amount") + "";
	let t3;
	let t4;
	let div2;
	let t6;
	let div5;
	let input0;
	let t7;
	let div4;
	let img;
	let img_src_value;
	let t8;
	let span0;
	let t9;
	let t10;
	let tokenselectmodal0;
	let t11;
	let t12;
	let div7;
	let t13;
	let div12;
	let div9;
	let t15;
	let div11;
	let input1;
	let input1_value_value;
	let t16;
	let div10;
	let span1;
	let t17_value = /*tokenOut*/ ctx[4].symbol + "";
	let t17;
	let t18;
	let tokenselectmodal1;
	let t19;
	let center;
	let button;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (approach === "add") return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type(ctx);

	tokenselectmodal0 = new TokenSelectModal({
			props: {
				tokens: /*tokensSwapIn*/ ctx[11],
				open: /*tokenSelectModalOpen*/ ctx[0],
				callback: /*tokenSelectCallback*/ ctx[8]
			}
		});

	let if_block1 = /*isLoading*/ ctx[10] === true && create_if_block_2(ctx);
	let if_block2 = /*tokenOut*/ ctx[4].type === "UniswapV2" && create_if_block_1(ctx);

	tokenselectmodal1 = new TokenSelectModal({
			props: {
				tokens: /*tokensSwapOut*/ ctx[12],
				open: /*tokenSelectModalOpen2*/ ctx[1],
				callback: /*tokenSelectCallback2*/ ctx[9]
			}
		});

	function select_block_type_1(ctx, dirty) {
		if (approach === "add") return create_if_block;
		return create_else_block;
	}

	let current_block_type_1 = select_block_type_1(ctx, -1);
	let if_block3 = current_block_type_1(ctx);

	return {
		c() {
			div13 = element("div");
			h1 = element("h1");
			if_block0.c();
			t0 = space();
			p = element("p");
			div0 = element("div");
			div0.textContent = "Use ZapIn";
			t2 = space();
			div6 = element("div");
			div3 = element("div");
			div1 = element("div");
			t3 = text(t3_value);
			t4 = space();
			div2 = element("div");
			div2.textContent = "‚ö†Ô∏è slippage might apply";
			t6 = space();
			div5 = element("div");
			input0 = element("input");
			t7 = space();
			div4 = element("div");
			img = element("img");
			t8 = space();
			span0 = element("span");
			t9 = text(/*tokenSymbol*/ ctx[5]);
			t10 = space();
			create_component(tokenselectmodal0.$$.fragment);
			t11 = space();
			if (if_block1) if_block1.c();
			t12 = space();
			div7 = element("div");
			if (if_block2) if_block2.c();
			t13 = space();
			div12 = element("div");
			div9 = element("div");
			div9.innerHTML = `<div class="left float-left">Approx. LP tokens</div>`;
			t15 = space();
			div11 = element("div");
			input1 = element("input");
			t16 = space();
			div10 = element("div");
			span1 = element("span");
			t17 = text(t17_value);
			t18 = space();
			create_component(tokenselectmodal1.$$.fragment);
			t19 = space();
			center = element("center");
			button = element("button");
			if_block3.c();
			attr(h1, "class", "text-center text-xl");
			attr(p, "class", "text-center font-thin my-4 mx-2");
			attr(div0, "class", "text-left md:my-16px md:mx-20px");
			attr(div1, "class", "left float-left");
			attr(div2, "class", "right font-bold text-xs py-1px text-center align-right float-right rounded");
			attr(div3, "class", "top h-32px text-sm font-thin px-4 py-4 md:py-2");
			attr(input0, "type", "number");
			attr(input0, "class", "font-thin text-base w-60pc md:w-75pc md:text-xl");
			attr(img, "class", "token-icon w-20px h-20px md:h-26px md:w-26px my-4px mx-2px");
			if (img.src !== (img_src_value = /*tokenLogo*/ ctx[6])) attr(img, "src", img_src_value);
			attr(img, "alt", /*tokenSymbol*/ ctx[5]);
			attr(span0, "class", "py-2px px-4px");
			attr(div4, "class", "asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex\n          align-middle justify-center items-center pointer mt-0 md:mt-14px");
			attr(div5, "class", "bottom px-4 py-4 md:py-2");
			attr(div6, "class", "input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(div7, "class", "my-16px mx-20px");
			attr(div9, "class", "top h-32px text-sm font-thin px-4 py-4 md:py-2");
			attr(input1, "type", "text");
			input1.disabled = true;
			input1.value = input1_value_value = /*ethNeededSingleEntry*/ ctx[3].label;
			attr(input1, "class", "font-thin text-base w-60pc md:w-75pc md:text-xl");
			attr(span1, "class", "py-2px px-4px");
			attr(div10, "class", "asset-btn float-right h-32px bg-grey-243 rounded-32px px-2px flex\n          align-middle justify-center items-center pointer mt-0 md:mt-14px");
			attr(div11, "class", "bottom px-4 py-4 md:py-2");
			attr(div12, "class", "input bg-white border border-solid rounded-8px border-grey-204 mx-0 md:mx-4");
			attr(button, "class", "btn m-0 mt-4 rounded-8px px-56px py-15px");
			attr(div13, "class", "liquidity-container bg-grey-243 rounded-4px p-4 md:p-6 w-full");
		},
		m(target, anchor) {
			insert(target, div13, anchor);
			append(div13, h1);
			if_block0.m(h1, null);
			append(div13, t0);
			append(div13, p);
			append(div13, div0);
			append(div13, t2);
			append(div13, div6);
			append(div6, div3);
			append(div3, div1);
			append(div1, t3);
			append(div3, t4);
			append(div3, div2);
			append(div6, t6);
			append(div6, div5);
			append(div5, input0);
			set_input_value(input0, /*amount*/ ctx[2]);
			append(div5, t7);
			append(div5, div4);
			append(div4, img);
			append(div4, t8);
			append(div4, span0);
			append(span0, t9);
			append(div5, t10);
			mount_component(tokenselectmodal0, div5, null);
			append(div13, t11);
			if (if_block1) if_block1.m(div13, null);
			append(div13, t12);
			append(div13, div7);
			if (if_block2) if_block2.m(div7, null);
			append(div13, t13);
			append(div13, div12);
			append(div12, div9);
			append(div12, t15);
			append(div12, div11);
			append(div11, input1);
			append(div11, t16);
			append(div11, div10);
			append(div10, span1);
			append(span1, t17);
			append(div11, t18);
			mount_component(tokenselectmodal1, div11, null);
			append(div13, t19);
			append(div13, center);
			append(center, button);
			if_block3.m(button, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input0, "keyup", debounce(/*fetchQuote*/ ctx[13], 250)),
					listen(input0, "input", /*input0_input_handler*/ ctx[17]),
					listen(div4, "click", /*click_handler*/ ctx[18]),
					listen(div10, "click", /*click_handler_1*/ ctx[19]),
					listen(button, "click", /*click_handler_2*/ ctx[20])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if_block0.p(ctx, dirty);
			if ((!current || dirty & /*$_*/ 128) && t3_value !== (t3_value = /*$_*/ ctx[7]("general.amount") + "")) set_data(t3, t3_value);

			if (dirty & /*amount*/ 4 && to_number(input0.value) !== /*amount*/ ctx[2]) {
				set_input_value(input0, /*amount*/ ctx[2]);
			}

			if (!current || dirty & /*tokenLogo*/ 64 && img.src !== (img_src_value = /*tokenLogo*/ ctx[6])) {
				attr(img, "src", img_src_value);
			}

			if (!current || dirty & /*tokenSymbol*/ 32) {
				attr(img, "alt", /*tokenSymbol*/ ctx[5]);
			}

			if (!current || dirty & /*tokenSymbol*/ 32) set_data(t9, /*tokenSymbol*/ ctx[5]);
			const tokenselectmodal0_changes = {};
			if (dirty & /*tokenSelectModalOpen*/ 1) tokenselectmodal0_changes.open = /*tokenSelectModalOpen*/ ctx[0];
			tokenselectmodal0.$set(tokenselectmodal0_changes);

			if (/*tokenOut*/ ctx[4].type === "UniswapV2") {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					if_block2.m(div7, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!current || dirty & /*ethNeededSingleEntry*/ 8 && input1_value_value !== (input1_value_value = /*ethNeededSingleEntry*/ ctx[3].label) && input1.value !== input1_value_value) {
				input1.value = input1_value_value;
			}

			if ((!current || dirty & /*tokenOut*/ 16) && t17_value !== (t17_value = /*tokenOut*/ ctx[4].symbol + "")) set_data(t17, t17_value);
			const tokenselectmodal1_changes = {};
			if (dirty & /*tokenSelectModalOpen2*/ 2) tokenselectmodal1_changes.open = /*tokenSelectModalOpen2*/ ctx[1];
			tokenselectmodal1.$set(tokenselectmodal1_changes);
			if_block3.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(tokenselectmodal0.$$.fragment, local);
			transition_in(tokenselectmodal1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tokenselectmodal0.$$.fragment, local);
			transition_out(tokenselectmodal1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div13);
			if_block0.d();
			destroy_component(tokenselectmodal0);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_component(tokenselectmodal1);
			if_block3.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

let approach = "add";

function instance($$self, $$props, $$invalidate) {
	let $eth;
	let $balances;
	let $_;
	component_subscribe($$self, eth, $$value => $$invalidate(25, $eth = $$value));
	component_subscribe($$self, balances, $$value => $$invalidate(26, $balances = $$value));
	component_subscribe($$self, _, $$value => $$invalidate(7, $_ = $$value));
	window.B = BigNumber;
	let { poolAction } = $$props;
	let { method } = $$props; // NOTE: This really should be named poolAddress. Token is too generic.;
	let tokenSelectModalOpen = false;
	let tokenSelectModalOpen2 = false;

	const tokenSelectCallback = _token => {
		$$invalidate(0, tokenSelectModalOpen = false);

		if (_token) {
			$$invalidate(23, token = _token);
			setTimeout(fetchQuote, 1000);
		}
	};

	const tokenSelectCallback2 = _token => {
		$$invalidate(1, tokenSelectModalOpen2 = false);

		if (_token) {
			$$invalidate(4, tokenOut = _token);
			setTimeout(fetchQuote, 1000);
		}
	};

	let amount = "1.00000000";
	let ethKey;
	let ethBalance = 0;
	let ethNeededSingleEntry = { val: 0, label: "-" };
	let amountsRequired = {};
	let isLoading;

	const tokensSwapIn = [
		{
			symbol: "ETH",
			address: "0x0000000000000000000000000000000000000000",
			balance: "0",
			icon: getTokenImage("eth")
		},
		{
			symbol: "SNX",
			address: "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F",
			balance: "0",
			icon: getTokenImage("0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F")
		},
		{
			symbol: "UMA",
			address: "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828",
			balance: "0",
			icon: getTokenImage("0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828")
		}
	];

	const tokensSwapOut = [
		{
			symbol: "USDC/ETH",
			address: "0xb4e16d0168e52d35cacd2c6185b44281ec28c9dc",
			balance: "0",
			type: "UniswapV2",
			containing: [
				{
					symbol: "USDC",
					address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
					balance: "0",
					icon: getTokenImage("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48")
				},
				{
					symbol: "ETH",
					address: "0x0000000000000000000000000000000000000000",
					balance: "0",
					icon: getTokenImage("eth")
				}
			]
		},
		{
			symbol: "DEFI+S/DAI",
			address: "0x7aefaf3ea1b465dd01561b0548c9fd969e3f76ba",
			type: "UniswapV2",
			balance: "0",
			containing: [
				{
					symbol: "DEFI+S",
					address: "0xaD6A626aE2B43DCb1B39430Ce496d2FA0365BA9C",
					balance: "0",
					icon: getTokenImage("0xaD6A626aE2B43DCb1B39430Ce496d2FA0365BA9C")
				},
				{
					symbol: "DAI",
					address: "0x6b175474e89094c44da98b954eedeac495271d0f",
					balance: "0",
					icon: getTokenImage("0x6b175474e89094c44da98b954eedeac495271d0f")
				}
			]
		}
	];

	const pieTokens = [];

	const fetchQuote = async (event, pieAddress = null) => {
		$$invalidate(3, ethNeededSingleEntry.label = "-", ethNeededSingleEntry);
		console.log("tokensSwapIn", tokensSwapIn);

		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		try {
			const { provider, signer } = get(eth);
			let contract = new ethers.Contract("0x80c5e6908368cb9db503ba968d7ec5a565bfb389", uniswapLpZapABI, provider);
			const requestedAmount = BigNumber(amount);
			console.log(`Swapping ${token.symbol} for ${tokenOut.symbol} containing ${tokenOut.containing[0].symbol}/${tokenOut.containing[1].symbol}`);
			const amountWei = requestedAmount.multipliedBy(10 ** 18).toFixed(0);

			let overrides = {
				value: token.address === tokensSwapIn[0].address
				? amountWei
				: "0"
			};

			let data = await contract.callStatic.ZapIn($eth.address, token.address, tokenOut.containing[0].address, tokenOut.containing[1].address, amountWei, "0", overrides); //_toWhomToIssue
			//_FromTokenContractAddress 
			//_ToUnipoolToken0
			//_ToUnipoolToken1
			//amount

			console.log("data", data.toString());

			$$invalidate(3, ethNeededSingleEntry = {
				val: data,
				label: ethers.utils.formatEther(data)
			});
		} catch(e) {
			console.log(e);

			if (e.reason === "SafeERC20: low-level call failed") {
				displayNotification({
					message: "Please Approve to check the LP amount estimantion.",
					type: "error",
					autoDismiss: 30000
				});
			} else {
				displayNotification({
					message: e.code,
					type: "error",
					autoDismiss: 30000
				});
			}
		}
	};

	onMount(async () => {
		
	});

	const action = async (evt, pooledToken) => {
		const { address } = pooledToken;

		if (pooledToken.actionBtnLabel === "Unlock") {
			evt.preventDefault();
			await approveMax(address, token);
		} else if (pooledToken.actionBtnLabel === "ready") {
			evt.preventDefault();
		}
	};

	const mintFromRecipe = async () => {
		const requestedAmount = BigNumber(amount);
		const max = BigNumber(ethBalance).multipliedBy(10 ** 18).toFixed(0);
		await fetchQuote();

		if (!$eth.address || !$eth.signer) {
			displayNotification({
				message: $_("piedao.please.connect.wallet"),
				type: "hint"
			});

			connectWeb3();
			return;
		}

		const percentagePlus = BigNumber(ethNeededSingleEntry.val.toString()).multipliedBy(BigNumber(1.05)).toFixed(0);

		if (BigNumber(percentagePlus).isGreaterThan(BigNumber(max))) {
			const maxFormatted = amountFormatter({ amount: max, displayDecimals: 8 });

			//TODO i18n
			const message = `Not enough ETH`;

			displayNotification({
				message,
				type: "error",
				autoDismiss: 30000
			});

			return;
		}

		const recipe = await contract({
			address: "0xca9af520706a57cecde6f596852eabb5a0e6bb0e",
			abi: recipeAbi
		});

		const amountWei = requestedAmount.multipliedBy(10 ** 18).toFixed(0);
		let overrides = { value: percentagePlus };

		console.log({
			pie: token,
			amountWei,
			value: ethNeededSingleEntry.val
		});

		const { emitter } = displayNotification(await recipe.toPie(token, amountWei, overrides));

		emitter.on("txConfirmed", ({ hash }) => {
			const { dismiss } = displayNotification({
				message: "Confirming...",
				type: "pending"
			});

			const subscription = subject("blockNumber").subscribe({
				next: () => {
					displayNotification({
						autoDismiss: 15000,
						message: `${requestedAmount.toFixed()} ${tokenSymbol} successfully minted`,
						type: "success"
					});

					dismiss();
					subscription.unsubscribe();
				}
			});

			return {
				autoDismiss: 1,
				message: "Mined",
				type: "success"
			};
		});
	};

	const primaryAction = () => {
		if (type === "single") {
			mintFromRecipe();
			return;
		}

		if (approach === "add") {
			mint();
		} else {
			withdraw();
		}
	};

	function input0_input_handler() {
		amount = to_number(this.value);
		$$invalidate(2, amount);
	}

	const click_handler = () => $$invalidate(0, tokenSelectModalOpen = true);
	const click_handler_1 = () => $$invalidate(1, tokenSelectModalOpen2 = true);
	const click_handler_2 = () => primaryAction();

	$$self.$$set = $$props => {
		if ("poolAction" in $$props) $$invalidate(15, poolAction = $$props.poolAction);
		if ("method" in $$props) $$invalidate(16, method = $$props.method);
	};

	let token;
	let tokenSymbol;
	let tokenLogo;
	let tokenOut;
	let type;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*token*/ 8388608) {
			$: $$invalidate(5, tokenSymbol = (token || {}).symbol);
		}

		if ($$self.$$.dirty & /*token*/ 8388608) {
			$: $$invalidate(6, tokenLogo = (token || {}).icon);
		}

		if ($$self.$$.dirty & /*$eth*/ 33554432) {
			$: if ($eth.address) {
				fetchEthBalance($eth.address);
				$$invalidate(21, ethKey = balanceKey(ethers.constants.AddressZero, $eth.address));
			}
		}

		if ($$self.$$.dirty & /*$balances, ethKey*/ 69206016) {
			$: ethBalance = BigNumber($balances[ethKey]).toString();
		}
	};

	$: $$invalidate(23, token = tokensSwapIn[0] || {});
	$: $$invalidate(4, tokenOut = tokensSwapOut[1] || {});
	$: type = "single";

	return [
		tokenSelectModalOpen,
		tokenSelectModalOpen2,
		amount,
		ethNeededSingleEntry,
		tokenOut,
		tokenSymbol,
		tokenLogo,
		$_,
		tokenSelectCallback,
		tokenSelectCallback2,
		isLoading,
		tokensSwapIn,
		tokensSwapOut,
		fetchQuote,
		primaryAction,
		poolAction,
		method,
		input0_input_handler,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class Migration extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { poolAction: 15, method: 16 });
	}
}

export default Migration;